<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>kotlin学习笔记</title>
      <link href="/2018/07/22/kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/07/22/kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>以前android的开发大部分使用java开发,而由于kotlin的推出,公司也开始转向了使用kotlin,所以在这里记录下学习kotlin的笔记.<br>  <a id="more"></a></p><h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><p>在kotlin中没有基本类型,其中一切都是对象,这也导致了其没有自动转换类型的功能,如folat不会自动上转为double之类的,而在java的基础类型之间转换需要调用其中的方法,虽然在本文中,多出地方使用了关键字,但其也是一个对象,只是作者沿用了java的说法.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val i :Int = 7</span><br><span class="line">val d :Double = i.toDouble()//Int对象中的转换方法</span><br><span class="line">val s = &quot;eeeee&quot;//String类型的s</span><br><span class="line">val c = s[0]//kotlin的字符串类型也可以像数组那样字节访问,且可以当做数组来迭代</span><br></pre></td></tr></table></figure></p><h2 id="定义包和导入包"><a href="#定义包和导入包" class="headerlink" title="定义包和导入包"></a>定义包和导入包</h2><p>这个与java的使用时一样的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">package com.lewis.test</span><br><span class="line"></span><br><span class="line">import com.lewis.test.util</span><br></pre></td></tr></table></figure></p><h2 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h2><p>kotlin中的函数使用fun作为关键字来定义,返回值在函数参数声明后使用”:”冒号来定义返回值类型,当然也可以让其自动判断返回类型,返回参数也使用return返回<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun sum(a :Int,b:Int) : Int&#123;</span><br><span class="line">return a+b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun sum(a:Int,b:Int) = a + b//自动推断返回的(a+b)的类型</span><br><span class="line"></span><br><span class="line">fun sum(a:Int,b:Int) = &#123; a + b&#125;//这里返回的是a+b的类型,如Int</span><br></pre></td></tr></table></figure><p>kt中无返回值(返回无意义的值),也就是java中的void,其使用关键字Unit,当然这个关键字一般是可以省略的,如下两个函数,其返回值是Unit(无返回值)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> fun test()&#123;</span><br><span class="line">println(&quot;555&quot;)</span><br><span class="line">&#125;</span><br><span class="line">fun test() :Unit&#123;</span><br><span class="line">println(&quot;555&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>kotlin的函数可以使用参数默认值,这是java所不支持的,其使用与C++的默认参数类似,但也有点不同<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fun defultTest(name :String ,age:Int,sex : String = &quot;Man&quot;)&#123;//此处的第三个参数有默认值Man</span><br><span class="line">    print(name+sex+age)</span><br><span class="line">&#125;</span><br><span class="line">defultTest(&quot;lewis&quot;,23)//第三个参数可以省略,其默认为Man,相当于defultTest(&quot;lewis&quot;,23,&quot;Man&quot;)</span><br><span class="line">defultTest(&quot;lewis&quot;,23,&quot;women&quot;)//这里就不使用默认参数,使用women值</span><br></pre></td></tr></table></figure></p><p>这里有个小扩展,在C++中的默认参数一定要放在函数参数列表的后面,否则会报错,但kotlin这样用却不会报错,个人认为将默认参数放在中间这是一个意义不大的事情<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fun defultTest(name :String ,sex : String = &quot;Man&quot;,age:Int)&#123;&#125;</span><br><span class="line">//像这种情况,在调用时因为第三个参数没有默认值,所以一定要传第三个值,所以这里也导致了第二个值一定要传,所以这里,个人认为在实际开发中尽量避免这样的设计</span><br></pre></td></tr></table></figure></p><h2 id="可变长度的参数"><a href="#可变长度的参数" class="headerlink" title="可变长度的参数"></a>可变长度的参数</h2><p>在java中可以使用…来表示函数传入的参数长度不固定,而kotlin中也有这功能,但不是…,而是vararg关键字<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fun argTest(vararg data:String)&#123;</span><br><span class="line">println(data.size)</span><br><span class="line">    println(data.toList())//转换为list,并调用toString()输出,直接输出data是一个数组对象</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="局部函数"><a href="#局部函数" class="headerlink" title="局部函数"></a>局部函数</h2><p>kotlin中有局部函数,从名字看,就是函数中的函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fun save(str:String)&#123;</span><br><span class="line">fun isEmpty(str:String)&#123;//定义一个内部函数</span><br><span class="line">if (str == null)&#123; throw NullpointException(&quot;null&quot;)&#125;</span><br><span class="line">&#125;</span><br><span class="line">isEmpty(str)//在函数内部直接调用,在外部不可调用</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="局部参数定义"><a href="#局部参数定义" class="headerlink" title="局部参数定义"></a>局部参数定义</h2><p>val定义的只能赋值一次,类似于java的final;var定义可变类型,类似java定义的普通变量;两种定义的使用方式基本类型,其不同之处只是在定以后val的参数不可以再次赋值,而var可以<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fun main(args : Array&lt;String&gt;)&#123;</span><br><span class="line">val a:Int = 1</span><br><span class="line">val b = 2//自动识别b为int类型</span><br><span class="line">val c: Int//定义c,其类型为int,此时的类型不可以省略</span><br><span class="line">c = 3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fun main(args:Array&lt;String&gt;)&#123;</span><br><span class="line">var d = 5//自动识别d为int</span><br><span class="line">d += 1//运算符和java一样用</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中可以使用as关键字类转换类型,父子类的转换或强制转换<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var a:Int = 3 as Any as Int//这里是将3转换成Any类型,在转换为Int类型(这里只是作为一个例子,没有任何实际意义)</span><br></pre></td></tr></table></figure></p><h2 id="字符串模板"><a href="#字符串模板" class="headerlink" title="字符串模板"></a>字符串模板</h2><p>kt可使用”$”,在字符串中引用参数或将”${xxx}”xxx的结果转换为字符串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fun stringTest()&#123;</span><br><span class="line">    var a = 5</span><br><span class="line">    val str = &quot;a is $a&quot;//此时str的字符串赋值为&quot;a is 5&quot;</span><br><span class="line">    a = 1</span><br><span class="line">    println(str.replace(&quot;is&quot;,&quot;was&quot;)+&quot;,but now is $a&quot;)</span><br><span class="line">    println(&quot;$&#123;str.replace(&quot;is&quot;,&quot;was&quot;)&#125;,but now is $a&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="if条件判断"><a href="#if条件判断" class="headerlink" title="if条件判断"></a>if条件判断</h2><p>kt中的if与java的用法类似,可以说java怎么用,kt就可以怎么用,但kt有更多的用法,如kt的if是可以用返回值的,在if的代码块的最后一句,如果为一个值,那么他就是if的返回值,这里需要注意的是,如果需要其有返回值,那每一个if条件的代码块的最后一行都需要是有一个同类型的值,否则无返回值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fun ifTest(): Int &#123;</span><br><span class="line">    var result =  if (3 == 4) 3 else 4</span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun ifTest2():Int&#123;</span><br><span class="line">return if(3==4)println(3)else 4//这样子if是没有返回值的,且编译器会报错</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="null可空值"><a href="#null可空值" class="headerlink" title="null可空值"></a>null可空值</h2><p>在kt中,要是某个值可为null时,需要再声明的类型后面添加?,来表示该应用可以为空;<br>且在这个参数使用时加上?使用,可在其不为空时才调用,在为空时不调用;<br>使用!!来保证不为空时才调用,为空时抛出异常;<br>使用?:来给其在空时的默认值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var a : Int? = null</span><br><span class="line">var a: Int = null//此处会报错</span><br><span class="line">fun getInt():Int?&#123;//这里的返回可以为null</span><br><span class="line">...</span><br><span class="line">var a:String? = null</span><br><span class="line">a?.length()//这里只有在a不为空时才会调用</span><br><span class="line">a!!.length()//这里a为空时会直接抛出异常</span><br><span class="line">a?.length() ?:0//这里在a为空的时候,使用默认值0</span><br><span class="line">a.length()//这里是不能通过编译的,因为a在这里有可能为空</span><br><span class="line">a as? String//这里是a不为空时将a转换为String类型,否者返回null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="类型检测及自动类型转换"><a href="#类型检测及自动类型转换" class="headerlink" title="类型检测及自动类型转换"></a>类型检测及自动类型转换</h2><p>kt中使用is关键字来检测类型,且检测后的分支中可以直接当该类型使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fun getStringLength(obj:Any):Int?&#123;//Any为任何类型,类似于java的object</span><br><span class="line">if (obj is String)&#123;</span><br><span class="line">return obj.length//此分支中,obj的类型为String</span><br><span class="line">&#125;</span><br><span class="line">//出了分支obj还是String</span><br><span class="line">return null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><p>kt中使用in关键字来循环遍历<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fun forTest(args:Array&lt;String&gt;)&#123;</span><br><span class="line">for(item in args)&#123;//遍历其数组中的元素</span><br><span class="line">println(item)//此处不可做删除操作,否则会抛异常</span><br><span class="line">&#125;</span><br><span class="line">for(index in args.indices)&#123;//遍历其数组中的下标</span><br><span class="line">println(args[index])//此处也不可做删除操作,删除了数组的大小会变小,在最后就会出现数组越界,所以如果删除了元素就要做相应的保护措施</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="区间"><a href="#区间" class="headerlink" title="区间"></a>区间</h2><p>kotlin中有使用..来表示区间<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(x in 1..3)&#123;//x是否在1到3之间,包括1和3,如果为!in为如果不在1到3的区间</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>迭代区间<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">for(x in 1..5)&#123;//包括1和5</span><br><span class="line">println(x)//1 2 3 4 5</span><br><span class="line">&#125;</span><br><span class="line">for(x in 1..5 step 2)&#123;//包括1和5,step 2表示迭代时每次迭代的步长为2</span><br><span class="line">println(x)//1 3 5</span><br><span class="line">&#125;</span><br><span class="line">for(x in 1 util 5)&#123;//1到5,此处不包括5,一般用于遍历列表</span><br><span class="line">println(x)//1 2 3 4</span><br><span class="line">&#125;</span><br><span class="line">for(x in 100 downTo 1 step 3)&#123;//downTo是递减,这里是从100递减到1,步长为3,就是每次-3,包括1和100</span><br><span class="line">println(x)//100 97 94 91...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h2><p>这个与java 的一样使用</p><h2 id="when表达式"><a href="#when表达式" class="headerlink" title="when表达式"></a>when表达式</h2><p>类似于java 的swich,且when和if一样是有返回值的,返回值用法也和if的一样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fun whenTest(obj : Any) :String =</span><br><span class="line">when(obj)&#123;</span><br><span class="line">1 -&gt;&quot;111&quot;</span><br><span class="line">2,3-&gt;&quot;2,3&quot;//多个情况可使用逗号隔开</span><br><span class="line">4..7-&gt;&quot;4-7&quot;//使用区间也可以</span><br><span class="line">&quot;asd&quot; -&gt;&quot;aaaa&quot;</span><br><span class="line">is Long -&gt; &quot;long&quot;</span><br><span class="line">!is String -&gt; &quot;Not string&quot;</span><br><span class="line">else -&gt; &quot;unKnown&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当然when中可以不传参数,再不传的情况下,其分支条件需要为布尔值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">when&#123;</span><br><span class="line">true-&gt;&quot;true&quot;</span><br><span class="line">a ==0 || b == 0-&gt;&quot;false&quot;</span><br><span class="line">else &quot;null&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>kotlin的异常与java 的类似,也是使用try-catch-finally,但其和if一样是一个表达式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var result = try&#123;//这里无异常时会返回22,有异常时返回null,且一定会打印change</span><br><span class="line">Integer.parseInt(&quot;22&quot;)</span><br><span class="line">&#125; catch(e : NumberFormatException)&#123;</span><br><span class="line">null</span><br><span class="line">&#125;finally&#123;</span><br><span class="line">println(&quot;change&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="相等比较"><a href="#相等比较" class="headerlink" title="==相等比较"></a>==相等比较</h2><p>在kotlin中==是使用equals()比较的,是数值相等,而在java中,若对对象使用==,则是比较引用相等<br>在kotlin中,如果需要比较其引用相等,需要使用===,三等号</p><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class MainActivity&#123;</span><br><span class="line">&#125;</span><br><span class="line">class MainActivity2(name:String,surname:String)//此处的类内无任何操作,所以可以忽略大括号,且(name:String,surnameString)这个就是声明其的构造函数</span><br><span class="line">class MainActivity3(var name:String,var surname:String)//这个和上一个很像,但上一个的类中并没有声明有属性,但这个声明了name和surname两个参数</span><br><span class="line">class MainActivity4(var name:String,var surname:String)&#123;</span><br><span class="line">init&#123;</span><br><span class="line">...//这个方法块是在主构造函数的函数体</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>构造函数中声明了属性或类中声明的属性,会默认的有setter和getter方法,虽在在使用的时候像是直接在操作属性其实其是调用了对应的get和set方法,当然也可以修改默认的set和get方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Test()&#123;</span><br><span class="line">var change0 = 0</span><br><span class="line">var change1 = 1</span><br><span class="line"> get() &#123;</span><br><span class="line">            return field+1//field是保留值,指向获取的这个参数,这里就是指向change1</span><br><span class="line">        &#125;</span><br><span class="line">        set(value) &#123;this.change = 2&#125;</span><br><span class="line">//这里修改了change1的get和set的默认方法,对change0和change2没有影响</span><br><span class="line">var change = 2</span><br><span class="line">var change3 = 4</span><br><span class="line">private set//可以将访问其的权限设置为本类使用或其他的</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Test1(var name:String)&#123;//此处括号声名的就是此类的主构造函数,当存在主构造函数时,就不能有从构造函数</span><br><span class="line">&#125;</span><br><span class="line">class Test2&#123;//无主构造函数</span><br><span class="line">constructor(name:String)&#123;//从构造函数</span><br><span class="line">this(name,0)//和java一样,可以使用this来调用其他构造函数</span><br><span class="line">&#125;</span><br><span class="line">constructor(name:String,age:Int)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般来说,要使用主构造函数来实现,然后其他参数提供相应的默认值,来达到类似重载的功能</p><h3 id="类继承"><a href="#类继承" class="headerlink" title="类继承"></a>类继承</h3><p>kotlin中的类只能继承显示声明为open或abstract的类,其中open是可被重写的意思,abstract是抽象的意思<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">open class Test1(name: String)</span><br><span class="line">abstract class Test2(surname: String)</span><br></pre></td></tr></table></figure></p><p>向上面两个类的声明才可以被继承,继承时使用”:”来继承,而不是java中的extends关键字<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class Test3(name: String) : Test1(name)&#123;//这里在构建是会默认调用父类Test1(name:String)的构造方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>kotlin的方法默认是final,不可重写的,所以,如果需要可以重写就需要显示声名open,或设为abstract抽象方法,而继承后重写一定要使用override关键字,且override关键字默认为open,所以在重写后,若想此方法不可被重写就要显示的使用final,kotlin的final与java的类似<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">abstract class abTest&#123;</span><br><span class="line">abstract fun one()//子类必须重写</span><br><span class="line">open fun two()&#123;&#125;//子类可以重写,也可以不重写</span><br><span class="line">fun three()&#123;&#125;//子类不可重写</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口的实现与继承一样,都是使用”:”,接口内的方法默认都为open,且无实现体就默认为abstract<br>kotlin的接口定义也是使用interface关键字,且支持在接口中提供默认实现<br>无默认方法的,其子类一定要实现这个方法,如有默认实现的,子类可以不是实现,默认使用接口中的是实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">interface Clickable&#123;</span><br><span class="line">fun click()</span><br><span class="line">fun showOff() = println(&quot;default&quot;)//此方法有默认的实现</span><br><span class="line">&#125;</span><br><span class="line">interface Clickable2&#123;</span><br><span class="line">fun showOff() = println(&quot;default2&quot;)//此方法有默认的实现</span><br><span class="line">&#125;</span><br><span class="line">class Button : Clickable,Clickable2&#123;</span><br><span class="line">override fun click() = println(&quot;click&quot;)//override 是重写父类的编辑,在java中是一个注释且可有可无,但在kotlin中,如果是重写就一定要有override </span><br><span class="line">override fun showOff() &#123;//当实现的两个接口都有同一个方法,那子类一定要重写他,否则会报错</span><br><span class="line">super&lt;Clickable&gt;.showOff()//调用指定父类的实现</span><br><span class="line">super&lt;Clickable2&gt;.showOff()</span><br><span class="line"> println(&quot;Button&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里可以看出继承和实现的不同,继承需要加上其构造方法,而实现不用<br>除了方法之外,kotlin的接口还支持默认属性,且kotlin的接口不存储属性值,只有其子类才会存储<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface ITest&#123;</span><br><span class="line">val name :String//此处的name不可以赋值,且子类实现后必须重写此属性</span><br><span class="line">val age:Int//此处提供了get,其子类可以不重写age</span><br><span class="line">get() = 1</span><br><span class="line">&#125;</span><br><span class="line">class Test4(override val name :String) :ITest</span><br></pre></td></tr></table></figure></p><h3 id="可见性修饰符"><a href="#可见性修饰符" class="headerlink" title="可见性修饰符"></a>可见性修饰符</h3><p>在kotlin中有public/internal/protected/private,四种,默认为public,而java中默认为包私有,这和kotlin的不太一样,且kotlin没有包私有修饰符.protected与java的不同,只能是在本类和子类中可见,而kotlin转java是,internal会被转为public</p><p>修饰符    ||    类成员    ||    顶层声名<br>public(默认)    ||    所有地方可见    ||    所有地方可见<br>internal    ||    模块中可见    ||    模块中可见<br>protected     ||    子类可见    ||     无此用法<br>private    ||    类中可见    ||    文件中可见</p><h3 id="data数据类"><a href="#data数据类" class="headerlink" title="data数据类"></a>data数据类</h3><p>kotlin中提供了一个数据类,数据类中提供了equals/hashcode/toString方法的重写,还提供了copy方法来复制数据类,声名的关键字为data<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data class TestData(val name:String,var age:Int)</span><br></pre></td></tr></table></figure></p><h3 id="enum枚举类"><a href="#enum枚举类" class="headerlink" title="enum枚举类"></a>enum枚举类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum class EnumTest(val a:Int,val b:String )&#123;</span><br><span class="line">    ONE(1,&quot;1&quot;),TWO(2,&quot;2&quot;);//此处定义枚举类的值,若要定义方法,则要使用&quot;;&quot;隔开,这里是kotlin中唯一要使用&quot;;&quot;的地方</span><br><span class="line">    fun printAll() = println(&quot;$a,$b&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="扩展函数"><a href="#扩展函数" class="headerlink" title="扩展函数"></a>扩展函数</h3><p>这个就厉害了,可以类以外的一个地方对类方法进行扩展,也可以说是给类添加一个函数,然后在其他地方使用到这个类时,可以直接调用这个方法使用,如对Context添加一个Toast的方法<br>需要注意的是,扩展函数无法使用被扩展类的protected和private修饰的属性或方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//Test.kt</span><br><span class="line">fun Context.toast(message :CharSequence)&#123;</span><br><span class="line">    Toast.makeText(this,message,Toast.LENGTH_SHORT).show()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>//MainACtivity.kt<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class MainActivity : AppCompatActivity() &#123;</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        toast(&quot;nfh&quot;)//因为Activity是继承了Context,所以可以直接调用Context中扩展的函数toast</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当然除了可以添加函数,也可以添加属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public var Context.age: Int//对Context添加属性age,这样所有Context的子类及本身都有这个属性了</span><br><span class="line">    get() = age</span><br><span class="line">    set(value) &#123; age = value&#125;</span><br></pre></td></tr></table></figure></p><p>需要注意的是,扩展函数不能被子类重写,因为扩展函数会被当做静态类型来处理,而且当扩展函数名和成员函数名一样是会优先使用成员函数名</p><h3 id="内部类-嵌套类"><a href="#内部类-嵌套类" class="headerlink" title="内部类(嵌套类)"></a>内部类(嵌套类)</h3><p>在java中的内部类,如不声名为静态的,其会持有外部类的引用,而声名了静态类型则不持有<br>而在kotlin中默认是不持有的(相当于静态),如果需要持有外部类引用则需要使用inner关键字<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Outer&#123;</span><br><span class="line">inner class Inner&#123;</span><br><span class="line">fun getOut() : Outer = this@Outer//要使用外部类时,要使用this@去引用</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="密封类"><a href="#密封类" class="headerlink" title="密封类"></a>密封类</h3><p>关键字sealed,使用sealed声名的类,默认为open,其子类只能在本类中继承在类外不可继承(在kotlin1.1版本改为在文件中)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sealed class Expr&#123;</span><br><span class="line">calss Num():Expr()</span><br><span class="line">class Sum():Expr()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="kotlin基础之后的"><a href="#kotlin基础之后的" class="headerlink" title="kotlin基础之后的"></a>kotlin基础之后的</h1><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>协程有个特点就是轻量级:<br>协程与线程类似,但是他比线程更加的轻量级,如开启1000个线程和1000个协程去执行一个工作,其中的开启线程就是开了1000个线程,这里是非常消耗资源的,而1000个协程,其中只是开了几个或几十个线程去工作.</p><h3 id="协程的使用"><a href="#协程的使用" class="headerlink" title="协程的使用"></a>协程的使用</h3><p>使用协程需要导入一些包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">implementation &quot;org.jetbrains.kotlinx:kotlinx-coroutines-core:$kotlinCoroutinesVersion&quot;//版本用了0.20版本再高点低点问题不大</span><br><span class="line">implementation &quot;org.jetbrains.kotlinx:kotlinx-coroutines-android:$kotlinCoroutinesVersion&quot;//这个是android使用的包,这里会多一个使用handle调度协程所工作的线程的方法</span><br></pre></td></tr></table></figure></p><p>kotlin的协程可使用async或launch来开启,两者功能类似,只是async默认是异步的,即不会立即运行,且两者的返回值不同,launch返回一个Job对象,async返回一个Deferred( -一个轻量级、非阻塞的 future),而Deferred内部是继承了Job所以两者之间的差异并不是很大<br>使用协程时,需要给其指定协程所执行的上下文或环境(也可以说是在哪个线程),而0.20版本中提供了以下的默认环境<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//它里面定一个线程池，去处理你的代码块</span><br><span class="line">        CommonPool</span><br><span class="line">//无限制，就是当前什么线程就是什么线程。</span><br><span class="line">       Unconfined</span><br><span class="line">//安卓开发用的,用android的handler处理你的代码块，构造方法需要提供Handler</span><br><span class="line">        HandlerContext</span><br></pre></td></tr></table></figure></p><p>正式使用协程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">val fu = async(CommonPool  )&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">println(fu.isCancelled)//fu协程是否取消</span><br><span class="line"></span><br><span class="line">val obj = launch(Unconfined)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">obj.cancel()//取消obj协程</span><br><span class="line"></span><br><span class="line">val UI = HandlerContext(Handler(Looper.getMainLooper()), &quot;UI&quot;)</span><br><span class="line">launch(UI)&#123;//这里就是运行在UI线程中了</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="集合类"><a href="#集合类" class="headerlink" title="集合类"></a>集合类</h2><p>kotlin中使用的集合类是java的集合类,虽然如此,kotlin还为其添加了很多便于开发者操作的方法/函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val list = arrayListOf(1,4,6,46)//这里的list其实就是java的ArrayList</span><br><span class="line">val map = hashMapOf(1 to &quot;one&quot;,4 to &quot;four&quot;)//这里的map是java的HashMap</span><br></pre></td></tr></table></figure></p><h2 id="中缀调用"><a href="#中缀调用" class="headerlink" title="中缀调用"></a>中缀调用</h2><p>这个有一点点像C++中对运算符的重载的感觉,虽然表象上差距挺大的<br>像集合类中map中的to,这个就是个中缀调用,定义中缀调用函数的关键字是infix,他可以作用在普通函数(需要再一个类中的,顶层函数不可以)和扩展函数中且规定了其函数参数只能有一个,返回值可有可无<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">infix fun Int.infixTest(other:Int):Int &#123;//这里的定义了一个扩展函数,且支持中缀调用</span><br><span class="line">    println(this+other)</span><br><span class="line">    return this+other</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c infixTest 3//中缀调用方式,其会返回c+3的和</span><br><span class="line">c.infixTest(3)//当然这样子也是可以的,效果是一样的</span><br></pre></td></tr></table></figure></p><p>而kotlin中对Any提供了一个扩展函数to,其实现为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">infix fun Any.to(other:Any) = Pair(this,other)//Pair是kotlin标准库中的类,其存储了一个键值对,其实也就是两个元素,所以map初始化时可以使用to来定义每一个键值对</span><br></pre></td></tr></table></figure></p><h2 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h2><p>kotlin的字符串处理也是使用了java的字符串处理,只不过kotlin还为其添加了很多易用的扩展函数,如获取字符串第一个或最后一个字符的函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;12.654-A&quot;.split(&quot;.-&quot;.toRegex)//字符串分隔,这里使用Regex类型来解决一些字符问题</span><br><span class="line">&quot;12.654-A&quot;.split(&quot;.&quot;,&quot;-&quot;)//kotlin支持多个字符的切割</span><br><span class="line">&quot;&quot;&quot;/\.asd\&apos;&quot;&quot;&quot;//三重冒号也就是左右两边都是&quot;&quot;&quot;,被三重冒号包围的字符串为纯字符串,无任何的转义序列</span><br></pre></td></tr></table></figure></p><h2 id="类委托"><a href="#类委托" class="headerlink" title="类委托"></a>类委托</h2><p>kotlin中提供了类委托的操作,关键字为by,这委托是在实现一个接口时,将实现部分委托给一个属性,使得本类成为一个中转的类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class ListTest&lt;T&gt; (val list : List&lt;T&gt; = ArrayList()) : List&lt;T&gt; by list&#123;这里的ListTest类实现了List,其实现部分委托给了list属性</span><br><span class="line">override fun add(value : T)&#123;//重写add方法</span><br><span class="line">println(value)</span><br><span class="line">list.add(value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h2><p>在kotlin中实现单例非常的方便,使用object关键字就可以实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">object Test5&#123;//定义</span><br><span class="line">val data = &quot;data&quot;</span><br><span class="line">fun printAll()&#123;</span><br><span class="line">println(data)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Test5.printAll()//调用单例</span><br></pre></td></tr></table></figure></p><h2 id="伴生对象"><a href="#伴生对象" class="headerlink" title="伴生对象"></a>伴生对象</h2><p>伴生对象有点像java的静态方法,但kotlin中没有static这东西,而代替他的是使用顶层函数,但是顶层函数无法访问类的private成员,所以这是就需要伴生对象了,其关键字为companion,一般会配合object使用<br>并且伴生对象也支持扩展函数,一般可以声名一个空的伴生对象,留给之后扩展<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">companion object&#123;//定义伴生对象</span><br><span class="line">fun bar()&#123;</span><br><span class="line">println(&quot;伴生&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">A.bar()//调用时,可以直接通过类型名调用</span><br><span class="line">interface ITest&#123;</span><br><span class="line">&#125;</span><br><span class="line">class B&#123;</span><br><span class="line">companion object My : ITest&#123;//定义伴生对象,并给个名字My,且可以实现接口</span><br><span class="line">fun bar()&#123;</span><br><span class="line">println(&quot;伴生&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">B.My.bar()//调用时通过类名加伴生名字调用</span><br><span class="line">fun ITestTest(test:ITest)&#123;//此函数需要传入一个ITest</span><br><span class="line">&#125;</span><br><span class="line">ITestTest(B)//或者B.My</span><br></pre></td></tr></table></figure></p><h2 id="let函数"><a href="#let函数" class="headerlink" title="let函数"></a>let函数</h2><p>let函数有点像groovy的闭包,使用let后,可在{}中通过it或自定义为其他参数来使用调用者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var str :String? = &quot;666&quot;</span><br><span class="line">str?.let&#123;//此处会在str不为空的情况下,才调用let中的内容,否者不调用</span><br><span class="line">println(it.length)//此时使用的it其实就是str对象</span><br><span class="line">it.indexOf(1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="lateinit-属性延时初始化"><a href="#lateinit-属性延时初始化" class="headerlink" title="lateinit 属性延时初始化"></a>lateinit 属性延时初始化</h2><p>在使用lateinit可以声名一个不为空的属性,且声名时不初始化,在之后再初始化,这里的属性需要为var,如果为val的话就必须在构造函数中初始化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private lateinit var data:String</span><br><span class="line"></span><br><span class="line">fun setData(s:String)&#123;</span><br><span class="line">data = s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果在初始化之前就调用了data,那么就会报错..</p><h2 id="by-lazy惰性初始化"><a href="#by-lazy惰性初始化" class="headerlink" title="by lazy惰性初始化"></a>by lazy惰性初始化</h2><p>这个与上面的latinit不太一样,by lazy()是在使用的时候在进行相关的初始化,且默认线程安全<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class User(val name:String)&#123;</span><br><span class="line">var age by lazy&#123;</span><br><span class="line">loadAge()//此处为初始化的操作</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">var user =User(&quot;lewis_v&quot;)</span><br><span class="line">user.age//在此处调用age时才会进行age的初始化</span><br></pre></td></tr></table></figure></p><h2 id="Nothing类型"><a href="#Nothing类型" class="headerlink" title="Nothing类型"></a>Nothing类型</h2><p>Nothing类型作为函数返回值,表示这个函数不会正常结束,也表明这个函数不会返回任何东西<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fun fail(msg:String) : Nothing&#123;</span><br><span class="line">throw IllegalStateException(msg)</span><br><span class="line">&#125;</span><br><span class="line">fun fail(msg:String) : Nothing&#123;</span><br><span class="line">return 0//这里报错,不给编译,一定要出错才可以</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><p>kotlin的运算符重载与C++的类似,其关键字为operator,其可重载二元、一元、复合、比较运算符</p><h3 id="二元"><a href="#二元" class="headerlink" title="二元"></a>二元</h3><p>二元的有*/%+-运算<br>其对应的重载方法为<br>表达式    ||    函数名</p><ul><li>||    times<br>/    ||    div<br>%    ||    mod</li></ul><ul><li>||    plus</li></ul><ul><li>||    minus</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">data class User(var age:Int)&#123;</span><br><span class="line">operator fun plus(other:User):User&#123;//重载+号,+号左边的为自身,右边的为other,其他符号与这个一样操作</span><br><span class="line">return Point(age + other.age)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">User(5) + User(5) //此处的结果为User(10)</span><br></pre></td></tr></table></figure><h3 id="复合"><a href="#复合" class="headerlink" title="复合"></a>复合</h3><p>复合的有+= -= *= /= %=<br>其重载的方法与其二元运算符差不多,在其基础上加上Assign即可,如+号为plusAssign,-号minusAssign<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">data class User(var age:Int)&#123;</span><br><span class="line">operator fun plusAssign(other:User):User&#123;//重载+=号,+=号左边的为自身,右边的为other,其他符号与这个一样操作</span><br><span class="line">return Point(age + other.age)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">var user = User(5)</span><br><span class="line">user += User(5) //此处的结果user变为User(10)</span><br></pre></td></tr></table></figure></p><h3 id="一元"><a href="#一元" class="headerlink" title="一元"></a>一元</h3><p>一元的有++ – + - !<br>其对应的重载方法为<br>表达式    ||    函数名<br>+a    ||    unaryPlus<br>-a    ||    unaryMinus<br>!a    ||    not<br>++a,a++    ||    inc<br>–a,a–    ||    dec<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">data class User(var age:Int)&#123;</span><br><span class="line">operator fun inc():User&#123;//重载++号,一元没有参数传入,只有对自己进行操作,其他符号与这个一样操作</span><br><span class="line">return Point(age + 1)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">var user = User(5)</span><br><span class="line">user ++  //此处的结果user变为User(6)</span><br></pre></td></tr></table></figure></p><h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><p>==为重写equals<br>其余的&gt; &lt; &gt;= &lt;=之类的比较需要实现Comparable,实现其中的方法compareTo,在比较时,会比较此方法返回数值的大小</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>以上是前段时间学习kotlin的学习笔记,总的来说,kotlin使用上更加方便简洁,且内部已经提供了很多常用的操作如集合类的操作等等…</p>]]></content>
      
      <categories>
          
          <category> Kotlin </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>java阻塞队列</title>
      <link href="/2018/05/09/java%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/"/>
      <url>/2018/05/09/java%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>java提供了很多阻塞队列,在平时的开发中也会使用到,所以在此对java提供的阻塞队列进行一个了解总结<br><a id="more"></a></p><h1 id="首先"><a href="#首先" class="headerlink" title="首先"></a>首先</h1><p>java的阻塞队列都继承与BlockingQueue,其有共同的方法<br>boolean offer(Object o);//将数据o加入队列中,加入成功返回true,失败则为false,此方法不阻塞<br>boolean offer(Object o,long timeout,TimeUnit unit);//将o加入队列中,若timeout过后为未加入成功返回false,否则返回true,此方法会阻塞等待,unit为时间单位<br>put(Object o);//将数据o加入队列中,若队列没有空间则会阻塞当前的线程进行等待<br>Object poll();//取走队列头部的数据,如取不出则返回null<br>Object poll(long timeout,TimeUnit unit);//取走队列头部的数据,若取不出则等待timeout,等待后取不出返回null<br>Object take();//取出队列首部数据,若取不出则阻塞直到取出来<br>int drainTo(Collection c);//取出队列中所有数据放到容器c中,其中的排序为队列中的排序,返回取出的数量<br>int drainTo(Collection c,int maxLength);//取出队列的数据,最大数量为maxLength,返回实际获取得数量<br>其他队列基本都有实现以下的方法:<br>peek()与poll()功能一样<br>队列有add()方法,其内部实现与put()基本都是一样的.而且还有许多方法与列表方法一样用的,如size(),remove(),clear(),遍历时使用迭代器遍历.其中remove()为删除队头<br>队列的有界无界表明其是否指定或限定队列大小</p><h1 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h1><p>用数组实现的有界阻塞队列,按照先进先出的原则.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayBlockingQueueTest &#123;</span><br><span class="line">    ArrayBlockingQueue&lt;String&gt; arrayBlockingQueue = new ArrayBlockingQueue&lt;&gt;(5,true);//定义队列大小为5,队列为先进先出顺序,false为未指定顺序</span><br><span class="line">    ExecutorService executorService = Executors.newSingleThreadExecutor();//单线程的线程池</span><br><span class="line"></span><br><span class="line">    public ArrayBlockingQueueTest() &#123;</span><br><span class="line">        for (int i = 0;i&lt;6;i++)&#123;</span><br><span class="line">            put(&quot;数据:&quot;+i);//放入数据</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void put(String data)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            arrayBlockingQueue.put(data);//向队列中放入数据</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        handle();//开启线程处理</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void handle()&#123;</span><br><span class="line">        executorService.submit(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(&quot;处理中...&quot;);</span><br><span class="line">                try &#123;</span><br><span class="line">                    sleep(3000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                String data = null;</span><br><span class="line">                try &#123;</span><br><span class="line">                    data = arrayBlockingQueue.poll(1, TimeUnit.SECONDS);//取出数据,1秒内取不出返回null</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                if ( data != null) &#123;</span><br><span class="line">                    System.out.println(data+&quot;处理结束...&quot;);</span><br><span class="line">                &#125;else &#123;</span><br><span class="line">                    System.out.println(&quot;无数据处理...&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h1><p>基于链表的阻塞队列,按照先进先出,其加入队列与取出队列的线程使用独立的锁来控制同步,所以其有更高的并发效率,需要注意的是在初始化时如果不指定长度会默认为无限长,这有可能会占用较多的资源,使用方法与ArrayBlockingQueue一致.</p><h1 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h1><p>无界优先级队列,默认为升序,与Arrays.sort()方法排序类似,在初始化时可以指定其初始长度,默认为11,增长数量为当大于等于64长度时,为原长度的1.5被,当小于64的时候为原长度的2倍+2.初始化时可设置其排序的比较规则Comparator(),也可重写其compareTo方法.其无法排序同优先级</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class PriorityBlockingQueueTest &#123;</span><br><span class="line">    PriorityBlockingQueue&lt;String&gt; priorityBlockingQueue;</span><br><span class="line">    String[] strings;</span><br><span class="line"></span><br><span class="line">    Comparator&lt;String&gt; mComparator = new Comparator&lt;String&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public int compare(String o1, String o2) &#123;</span><br><span class="line">            return o2.length() - o1.length();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public boolean equals(Object obj) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    public PriorityBlockingQueueTest() &#123;</span><br><span class="line">        strings = new String[]&#123;&quot;666&quot;, &quot;6626&quot;, &quot;6645457645661234566&quot;, &quot;6612423564566&quot;, &quot;6644564564564564564564566&quot;, &quot;664566&quot;, &quot;664564566&quot;, &quot;664566&quot;&#125;;</span><br><span class="line">        priorityBlockingQueue = new PriorityBlockingQueue&lt;&gt;(11,mComparator);</span><br><span class="line">        priorityBlockingQueue.put(&quot;666&quot;);</span><br><span class="line">        priorityBlockingQueue.put(&quot;6626&quot;);</span><br><span class="line">        priorityBlockingQueue.put(&quot;6645457645661234566&quot;);</span><br><span class="line">        priorityBlockingQueue.put(&quot;6612423564566&quot;);</span><br><span class="line">        priorityBlockingQueue.put(&quot;6644564564564564564564566&quot;);</span><br><span class="line">        priorityBlockingQueue.put(&quot;664566&quot;);</span><br><span class="line">        priorityBlockingQueue.put(&quot;664564566&quot;);</span><br><span class="line">        priorityBlockingQueue.put(&quot;664566&quot;);</span><br><span class="line"></span><br><span class="line">        Iterator&lt;String&gt; iterator = priorityBlockingQueue.iterator();</span><br><span class="line">        while (iterator.hasNext()) &#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;-----------------------------------------&quot;);</span><br><span class="line">        Arrays.sort(strings,mComparator);</span><br><span class="line">        for (String data : strings)&#123;</span><br><span class="line">            System.out.println(data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果<br><img src="/images/java%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97PriorityBlockingQueue%E6%95%88%E6%9E%9C.png" alt="enter description here" title="java阻塞队列PriorityBlockingQueue效果.png"></p><p>经试验验证,其内部的排序使用二分法排序,如下代码,结果与想象的不一样,具体原因还有待研究<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private static &lt;T&gt; void siftUpUsingComparator(int k, T x, Object[] array,</span><br><span class="line">                                      Comparator&lt;? super T&gt; cmp) &#123;</span><br><span class="line">       while (k &gt; 0) &#123;</span><br><span class="line">           int parent = (k - 1) &gt;&gt;&gt; 1;//取中间值比较</span><br><span class="line">           Object e = array[parent];</span><br><span class="line">           if (cmp.compare(x, (T) e) &gt;= 0)//此处遇到返回大于等于0的就退出,退出操作有点问题</span><br><span class="line">               break;</span><br><span class="line">           array[k] = e;</span><br><span class="line">           k = parent;</span><br><span class="line">       &#125;</span><br><span class="line">       array[k] = x;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><h1 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h1><p>延时取出的无界队列,基于PriorityQueue实现的,加入的元素需要实现Delayed接口,目前并不会使用</p><h1 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h1><p>不存储元素的队列,当插入的一个元素,必须等待其他线程移除才可继续运行,当移除一个元素,如使用remove且无插入在等待会报错,使用take()会等到有元素插入了才返回,否则阻塞,其他的有就有没有就返回null.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public class SynchronoutsQueueTest &#123;</span><br><span class="line">    SynchronousQueue&lt;String&gt; stringSynchronousQueue = new SynchronousQueue&lt;&gt;();</span><br><span class="line">    public SynchronoutsQueueTest() &#123;</span><br><span class="line">        new MyThread().start();</span><br><span class="line">        try &#123;</span><br><span class="line">            stringSynchronousQueue.put(&quot;666&quot;);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;----------putEndMain----------&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(&quot;----------poll:&quot;+stringSynchronousQueue.take()+&quot;Main----------&quot;);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class MyThread extends Thread&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                sleep(3000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;----------poll:&quot;+stringSynchronousQueue.poll()+&quot;Thread----------&quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                sleep(3000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            try &#123;</span><br><span class="line">                stringSynchronousQueue.put(&quot;666&quot;);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;----------putEndThread----------&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果<br><img src="/images/java%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97SynchronousQueue.png" alt="enter description here" title="java阻塞队列SynchronousQueue.png"></p><h1 id="LinkedTransferQueue"><a href="#LinkedTransferQueue" class="headerlink" title="LinkedTransferQueue"></a>LinkedTransferQueue</h1><p>无界的链表队列,用于生产者等待消费者的需求,其实现了TransferQueue接口,其中有几个重要方法<br>transfer(Object o);//加入队列,如加入时没有取出队列操作,会阻塞等待取出.<br>boolean tryTransfer(Object o);//加入队列,如有取出的操作在等待则加入并返回true,否则不加入并返回false<br>boolean tryTransfer(Object o,long timeout,TimeUnit unit);//有超时机制的tryTransfer</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class LinkedTransferQueueTest &#123;</span><br><span class="line">    LinkedTransferQueue&lt;String&gt; linkedTransferQueue = new LinkedTransferQueue&lt;&gt;();</span><br><span class="line">    public LinkedTransferQueueTest() &#123;</span><br><span class="line">        new TestThread().start();</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(3000);</span><br><span class="line">                System.out.println(&quot;消费:&quot; + linkedTransferQueue.take());</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class TestThread extends Thread&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    System.out.println(&quot;出产...&quot;);</span><br><span class="line">                    linkedTransferQueue.transfer(&quot;34636&quot;);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果<br><img src="/images/java%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97LinkedTransferQueue.png" alt="enter description here" title="java阻塞队列LinkedTransferQueue.png"></p><p>在每次出产后都会等待消费后再进行下一次的出产</p><h1 id="LinedBlockingDeque"><a href="#LinedBlockingDeque" class="headerlink" title="LinedBlockingDeque"></a>LinedBlockingDeque</h1><p>双向阻塞队列,在初始化时可设置其最大容量,默认为int的最大值,队列提供了addFirst、addLast、offerFirst、offerLast、peekFirst、peekLast等方法进行对队头和队尾的操作。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>java提供的阻塞队列使用起来也是挺便利的,虽然有些可能写错了,希望大家指出纠正.</p>]]></content>
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Android好多好多的Drawable</title>
      <link href="/2018/05/09/Android%E5%A5%BD%E5%A4%9A%E5%A5%BD%E5%A4%9A%E7%9A%84Drawable/"/>
      <url>/2018/05/09/Android%E5%A5%BD%E5%A4%9A%E5%A5%BD%E5%A4%9A%E7%9A%84Drawable/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Android中提供了很多的Drawable,一般我们都是用来当做背景的,其实他还有很多其他的用途….<br><a id="more"></a></p><h1 id="有什么Drawable"><a href="#有什么Drawable" class="headerlink" title="有什么Drawable?"></a>有什么Drawable?</h1><p>bitmapDrawable<br>ShapeDrawable<br>LayerDrawable<br>StateListDrawable<br>LevelListDrawable<br>TransitionDrawable<br>InsetDrawable<br>ScaleDrawable<br>ClipDrawable</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>在drawable中,每个标签&lt;…&gt;显示的内容会按顺序绘制,所以放在后面的标签会覆盖前面的绘制</p><h2 id="bitmapDrawable"><a href="#bitmapDrawable" class="headerlink" title="bitmapDrawable"></a>bitmapDrawable</h2><p>显示图片,并对图片的显示进行处理,其中也可以对点9的图片进行处理,还有个NinePatchDrawable是用于显示点9图片的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;bitmap</span><br><span class="line">xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">android:src=&quot;@drawable/icon&quot;//设置显示的图片为icon</span><br><span class="line">android:antialias=&quot;true&quot;//抗锯齿功能,最好开启让图片更加平滑,虽然会模糊一点点</span><br><span class="line">android:dither=&quot;true&quot;//抖动效果,在相片像素和手机像素不一致或手机不支持其色彩模式时(有些低端机不支持ARGB8888格式,现在的应该都兼容,但是都不好说)会保持较好的显示效果,应该开启</span><br><span class="line">android:filter=&quot;true&quot;//过滤效果,当图片被拉伸或压缩时,保持良好的显示效果,应该开启</span><br><span class="line">android:gravity=&quot;center&quot;//当图片大小小于容器大小时,其显示的位置</span><br><span class="line">android:tileMode=&quot;disabled&quot;//平铺模式,默认关闭(disabled),开启时会覆盖gravity的设置,会议tileMode设置的平铺方式来填充容器,repeat(简单平铺,会使用多个本图片水平和竖直方向进行填充),mirror(水平和竖直方向上的镜面投影效果),clamp(边缘像素会向四周扩散)</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;nine-path</span><br><span class="line">.......//与bitmapDrawable一样</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure><h2 id="ShapeDrawable"><a href="#ShapeDrawable" class="headerlink" title="ShapeDrawable"></a>ShapeDrawable</h2><p>通过颜色来构造图形,可为纯色和渐变色<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;shape</span><br><span class="line">xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">android:shape=&quot;rectangle&quot;//图形的形状,默认为rectangle(矩形),还有oval(椭圆),line(横线)和ring(圆环).其中line和ring要使用&lt;stroke&gt;设置其宽度和颜色,否则显示会出问题</span><br><span class="line">(ring有特殊的属性,其他的都没有</span><br><span class="line">android:innerRadius=&quot;圆环内半径,与innerRadiusRatio同时存在时,以innerRadius为准&quot;</span><br><span class="line">android:innerRadiusRatio=&quot;内半径占整个Drawable宽度的比例,默认为9,内半径=宽度/9&quot;</span><br><span class="line">android:thickness=&quot;圆环厚度,与thicknessRatio同时存在时,以thickness为准&quot;</span><br><span class="line">android:thicknessRatio=&quot;圆环厚度占整个Drawable宽度的比例,默认为3,厚度=宽度/3&quot;</span><br><span class="line">android:useLevel=&quot;false&quot;//一般为False,在将其用于LevelListDrawable时才使用true</span><br><span class="line">)</span><br><span class="line">&gt;</span><br><span class="line">&lt;corners//四个角的角度(圆角度),仅适用于矩形</span><br><span class="line">android:radius=&quot;2dp&quot;//设置4个角的角度,会被另4个单独设置的属性覆盖</span><br><span class="line">android:topLeftRadius=&quot;2dp&quot;//左上角角度</span><br><span class="line">android:topRightRadius=&quot;2dp&quot;//右上角角度</span><br><span class="line">android:bottomLeftRadius=&quot;2dp&quot;/左下角角度</span><br><span class="line">android:bottomRightRadius=&quot;2dp&quot;//右下角角度</span><br><span class="line">/&gt;</span><br><span class="line">&lt;gradient//渐变色填充</span><br><span class="line">android:angle=&quot;0&quot;//渐变角度,必须为45的倍数</span><br><span class="line">android:centerX=&quot;0&quot;//渐变中心点的横坐标</span><br><span class="line">android:centerY=&quot;0&quot;//渐变中心点的纵坐标</span><br><span class="line">android:startColor=&quot; &quot;//渐变的起始色</span><br><span class="line">android:centerColor=&quot; &quot;//渐变中间色</span><br><span class="line">android:endColor=&quot; &quot;//渐变的结束色</span><br><span class="line">android:gradientRadius=&quot;&quot;//渐变半径,在type为radial(径向渐变)时有效</span><br><span class="line">android:useLevel=&quot;false&quot;//一般为false,在作为StateListDrawable时为true</span><br><span class="line">android:type=&quot;linear&quot;//渐变类别,默认为linear(线性渐变),radial(径向渐变),sweep(扫描先渐变)</span><br><span class="line">/&gt;</span><br><span class="line">&lt;solid//纯色填充</span><br><span class="line">android:color=&quot; &quot;//填充的颜色</span><br><span class="line">/&gt;</span><br><span class="line">&lt;stroke//描边,其中dashWidth和dashGap一起设置才会有效果</span><br><span class="line">android:width=&quot;2dp&quot;//描边的厚度</span><br><span class="line">android:color=&quot; &quot;//描边的颜色</span><br><span class="line">android:dashWidth=&quot;5dp&quot;//虚线描边的每节虚线长度</span><br><span class="line">android:dashGap=&quot;5dp&quot;//虚线之间的间隔长度</span><br><span class="line">/&gt;</span><br><span class="line">&lt;padding//所在的控件留白</span><br><span class="line">android:left=&quot;1dp&quot;</span><br><span class="line">android:right=&quot;1dp&quot;</span><br><span class="line">android:top=&quot;1dp&quot;</span><br><span class="line">android:bottom=&quot;1dp&quot;</span><br><span class="line">/&gt;</span><br><span class="line">&lt;size//shape的固有大小,但将drawable设置为背景时,其还是会根据控件的大小进行自适应</span><br><span class="line">android:width=&quot;10dp&quot;</span><br><span class="line">android:height=&quot;10dp&quot;</span><br><span class="line">/&gt;</span><br><span class="line">&lt;/shape&gt;</span><br></pre></td></tr></table></figure></p><h2 id="LayerDrawable"><a href="#LayerDrawable" class="headerlink" title="LayerDrawable"></a>LayerDrawable</h2><p>层次化的drawable集合,将不同的drawable放到不同的层去显示达到叠加后的效果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;layer-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line">&lt;item//一个item为一层显示,后面的item后遮盖上面的item</span><br><span class="line">android:drawable=&quot; &quot;//显示的drawable</span><br><span class="line">android:id=&quot; &quot;//设置id</span><br><span class="line">android:top=&quot; &quot;//顶部偏移量</span><br><span class="line">android:bottom=&quot; &quot;//底部偏移量</span><br><span class="line">android:left=&quot; &quot;//左边偏移量</span><br><span class="line">android:right=&quot; &quot;//右边偏移量</span><br><span class="line">/&gt;</span><br><span class="line">&lt;item</span><br><span class="line">...&gt;</span><br><span class="line">&lt;shape ...&gt;//也可以在item中直接自定义drawable</span><br><span class="line">&lt;/item&gt;</span><br><span class="line">&lt;/layer-list&gt;</span><br></pre></td></tr></table></figure><h2 id="StateListDrawable"><a href="#StateListDrawable" class="headerlink" title="StateListDrawable"></a>StateListDrawable</h2><p>根据view的不同状态来设置不同的背景</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line">android:constantSize=&quot;false&quot;//固有大小是否随drawable的改变而改变,默认false为改变</span><br><span class="line">android:dither=&quot;true&quot;//抖动效果</span><br><span class="line">android:variablePadding=&quot;true&quot;//其padding是否随drawable的改变而改变,默认为true不改变,其padding为所有drawable的最大值</span><br><span class="line">&gt;</span><br><span class="line">&lt;item//一个item表示一种状态 </span><br><span class="line">android:state_pressed=&quot;true&quot;//按下为松开的状态,false为不处于此状态</span><br><span class="line">android:drawable=&quot; &quot;//此状态下要先显示的drawable</span><br><span class="line">/&gt;</span><br><span class="line">//其他的状态</span><br><span class="line">//state_focused:view获取焦点</span><br><span class="line">//state_selected:用户选择了view</span><br><span class="line">//state_checked:用户选中了view,使用与checkBox</span><br><span class="line">//state_enabled:当前view可用</span><br><span class="line">//若没有注明状态,则为默认状态</span><br><span class="line">&lt;/selector&gt;</span><br></pre></td></tr></table></figure><h2 id="LevelListDrawable"><a href="#LevelListDrawable" class="headerlink" title="LevelListDrawable"></a>LevelListDrawable</h2><p>根据当前等级来显示不同的drawable,可通过Drawable或者ImageView的setImageLevel来设置等级,默认为0,最大等级为10000.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;level-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line">&lt;item//一个item为一个drawable,在其最大值和最小值之间的等级就会显示他</span><br><span class="line">android:drawable=&quot; &quot;//显示的drawable</span><br><span class="line">android:maxLevel=&quot; &quot;//最大的等级,默认为10000</span><br><span class="line">android:minLevel=&quot; &quot;//最小的等级,默认为0</span><br><span class="line">/&gt;</span><br><span class="line">&lt;/level-list&gt;</span><br></pre></td></tr></table></figure><h2 id="TransitionDrawable"><a href="#TransitionDrawable" class="headerlink" title="TransitionDrawable"></a>TransitionDrawable</h2><p>实现两个drawable之间的淡入淡出的转化效果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;transition xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line">&lt;item android:drawable=&quot; &quot;/&gt;//一个item代表一个</span><br><span class="line">&lt;item android:drawable=&quot; &quot;/&gt;</span><br><span class="line">&lt;/transition&gt;</span><br></pre></td></tr></table></figure><p>将上面的drawable设置为View的背景,要切换时在代码中调用如下代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TextView tv = findViewById(R.id.tv);</span><br><span class="line">TransitionDrawable drawable = (TransitionDrawable)tv.getBackGround();</span><br><span class="line">drawable.startTransition(1000);//开始转换动画,进行两个item的切换</span><br></pre></td></tr></table></figure></p><h2 id="InsetDrawable"><a href="#InsetDrawable" class="headerlink" title="InsetDrawable"></a>InsetDrawable</h2><p>将其他drawable内嵌到自身中并留白,可使drawable做背景时,比实际区域小</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;inset xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">android:drawable=&quot; &quot;//显示的drawable</span><br><span class="line">android:insetTop=&quot; &quot;//留白</span><br><span class="line">android:insetBottom=&quot; &quot;</span><br><span class="line">android:insetLeft=&quot; &quot;</span><br><span class="line">android:insetRight=&quot; &quot;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure><h2 id="ScaleDrawable"><a href="#ScaleDrawable" class="headerlink" title="ScaleDrawable"></a>ScaleDrawable</h2><p>根据等级缩放,其等级为0时不会显示,等级越大显示的越大,缩放越大显示的越小.需要注意的是,其缩放公式(伪代码)为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(level != 0)&#123;</span><br><span class="line">width -= width * (10000-level) * scaleWidth/10000</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;scale xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">android:drawable=&quot; &quot;//显示的drawable</span><br><span class="line">android:scaleGravity=&quot; &quot;//与gravity一样</span><br><span class="line">android:scaleHeight=&quot;25%&quot;//按比例缩放高</span><br><span class="line">android:scaleWidth=&quot;25%&quot;//按比例缩放宽</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure><p>以上的drawable没有设置等级,无法显示,可在代码中设置等级<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((ScaleDrawable)view.getBackground()).setlevel(1);//设置drawable的等级</span><br></pre></td></tr></table></figure></p><h2 id="ClipDrawable"><a href="#ClipDrawable" class="headerlink" title="ClipDrawable"></a>ClipDrawable</h2><p>用于裁剪drawable,其等级表示裁剪剩余多少,如0为全裁剪,10000为不裁剪,666为裁剪(666/10000)*100%</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;clip xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">android:drawable=&quot; &quot;//处理的drawable</span><br><span class="line">android:clipOrientation=&quot; &quot;//裁剪方向,horizontal(水平方向),vertical(竖直方向)</span><br><span class="line">android:gravity=&quot; &quot;//裁剪方式</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure><p>裁剪方式比较多,且可以多个使用”|”一起组合<br>top : 放在顶部,为vertical时,从底部开始裁剪,不改变大小<br>bottom : 放在底部,为vertical时,从顶部开始裁剪,不改变大小<br>left : 放在左边,为horizontal时,从右边开始裁剪,不改变大小<br>right : 放在右边,为horizontal时,从左边开始裁剪,不改变大小<br>center_vertical : 竖直居中,为vertical时,上下同时开始裁剪,不改变大小<br>fill_vertical : 竖直方向上填充容器,会改变大小,当等级为0时会不显示<br>center_horizontal : 水平居中,horizontal时,从左右两边同时裁剪,不改变大小<br>fill_horizontal : 水平方向上填充容器,会改变大小,等级为0时不显示<br>center : 水平和竖直方向都居中,为vertical时,上下同时裁剪,为horizontal时,左右同时裁剪,不改变大小<br>fill : 水平和竖直方向同时填充,会改变大小,等级为0时不显示<br>clip_vertical : 竖直方向的裁剪<br>clip_horizontal : 水平方向的裁剪</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>Drawable一般用来作为控件的背景,而android提供了很多的Drawable,这些已经可以满足一般开发的需求,并且使用drawable可以很轻松的实现我们想要的效果~~</p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Android 语音录制及播放的处理---AudioH</title>
      <link href="/2018/04/18/Android-%E8%AF%AD%E9%9F%B3%E5%BD%95%E5%88%B6%E5%8F%8A%E6%92%AD%E6%94%BE%E7%9A%84%E5%A4%84%E7%90%86-AudioH/"/>
      <url>/2018/04/18/Android-%E8%AF%AD%E9%9F%B3%E5%BD%95%E5%88%B6%E5%8F%8A%E6%92%AD%E6%94%BE%E7%9A%84%E5%A4%84%E7%90%86-AudioH/</url>
      <content type="html"><![CDATA[<p>Android 语音录制及播放的处理,基于MediaPlayer(播放) 和MediaRecorder (录制)</p><p>github地址：<a href="https://github.com/lewis-v/AudioH" target="_blank" rel="noopener">https://github.com/lewis-v/AudioH</a><br><a id="more"></a></p><h2 id="实现功能"><a href="#实现功能" class="headerlink" title="实现功能"></a>实现功能</h2><p>1.实现Android语音录制的功能（目前封装只支持AMR格式）；</p><p>2.实现Android语音播放功能（听筒和扬声器播放）；</p><p>3.实现语音播放中，网络语音的缓存；</p><p>4.提供获取缓存大小和清理缓存的方法；</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><h3 id="1-导入依赖"><a href="#1-导入依赖" class="headerlink" title="1.导入依赖"></a>1.导入依赖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">repositories &#123;</span><br><span class="line">...</span><br><span class="line">maven &#123; url &apos;https://jitpack.io&apos; &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">        compile &apos;com.github.lewis-v:AudioH:1.0.0&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-录音"><a href="#2-录音" class="headerlink" title="2.录音"></a>2.录音</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">RecoderBuilder builder = new DefaultRecoderBuilder()</span><br><span class="line">               .setMAX_LENGTH(60*1000)//最大录音60秒</span><br><span class="line">               .setMIN_LENGTH(500)//最小录音0.5秒</span><br><span class="line">               .setSAMPLEING_RATE(200)//录音监听回调间隔，200ms回调一次</span><br><span class="line">               .setSaveFolderPath(Environment.getExternalStorageDirectory()+&quot;/record/&quot;);</span><br><span class="line">       AudioRecoderManager.getInstance()//获取单例</span><br><span class="line">               .setAudioRecoderData(builder.create())//设置自定义配置，已有默认的配置，可不用配置</span><br><span class="line">               .setAudioRecoderListener(new AudioRecoderListener() &#123;//设置监听</span><br><span class="line">                   @Override</span><br><span class="line">                   public void onStart() &#123;//开始播放</span><br><span class="line"></span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   @Override</span><br><span class="line">                   public void onStop(AudioRecoderData audioRecoderData) &#123;//停止/结束播放</span><br><span class="line">                       Log.e(TAG,audioRecoderData.getFilePath());</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   @Override</span><br><span class="line">                   public void onFail(Exception e, String msg) &#123;//录音时出现的错误</span><br><span class="line">                       e.printStackTrace();</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   @Override</span><br><span class="line">                   public void onCancel() &#123;//录音取消</span><br><span class="line"></span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   @Override</span><br><span class="line">                   public void onSoundSize(int level) &#123;//录音时声音大小的回调，分贝</span><br><span class="line">                       Log.e(TAG,&quot;level:&quot;+level);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;);</span><br><span class="line">               </span><br><span class="line"> AudioRecoderManager.getInstance().start(this);//开始录音</span><br><span class="line"> AudioRecoderManager.getInstance().stop(this);//结束录音</span><br></pre></td></tr></table></figure><h3 id="3-播放"><a href="#3-播放" class="headerlink" title="3.播放"></a>3.播放</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">AudioPlayManager.getInstance().init(this)//初始化播放</span><br><span class="line">                .setPlayListener(new AudioPlayListener() &#123;//设置播放监听</span><br><span class="line">            @Override</span><br><span class="line">            public void onPlay(String audioPath) &#123;//开始播放</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onProgress(int progress, int maxSize) &#123;//播放进度（未实现）</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onPause() &#123;//播放暂停（未实现）</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onStop() &#123;//停止播放</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onFail(Exception e, String msg) &#123;//播放时出错</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">   </span><br><span class="line">   AudioPlayManager.getInstance().play(&quot;http://39.108.236.30:47423/audio/UP699813445282012.amr&quot;</span><br><span class="line">                                ,this, AudioPlayMode.MEGAPHONE);//播放音频,放心这段音频是我朋友的声音。。嘻嘻</span><br></pre></td></tr></table></figure><h3 id="4-缓存获取及清理"><a href="#4-缓存获取及清理" class="headerlink" title="4.缓存获取及清理"></a>4.缓存获取及清理</h3><p>缓存清理的方法未做线程处理，是同步进行的方法，需要开发者自己开子线程调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Log.e(TAG, String.valueOf(AudioPlayManager.getInstance().getCacheSize(this)));//获取缓存大小</span><br><span class="line">Log.e(TAG, String.valueOf(AudioPlayManager.getInstance().clearCache(this)));//清除缓存，并返回清除的大小</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Android Gradle学习笔记</title>
      <link href="/2018/04/18/Android-Gradle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/04/18/Android-Gradle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>gradle使用的脚本语言是Groovy,Groovy完全兼容java<br><a id="more"></a></p><h1 id="DSL"><a href="#DSL" class="headerlink" title="DSL"></a>DSL</h1><p>DSL的意思是领域特定语言,即专注于一个领域的语言,而像java是一种通用全面的语言,而Gradle就是一门DSL,基于Groovy,专注于自动化构建.</p><h1 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h1><p>def 用于参数/方法的定义,定义可不用定义返回类型<br>&lt;&lt; 此符号队伍任务来说相当于doLast,将任务放到任务队列的队尾执行</p><h1 id="Groovy的字符串表示"><a href="#Groovy的字符串表示" class="headerlink" title="Groovy的字符串表示"></a>Groovy的字符串表示</h1><p>Groovy的单引号和双引号都表示字符串,但单引号不具有计算功能,双引号有,如</p><p><img src="/images/Gradle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01.png" alt="enter description here" title="Gradle学习笔记1.png"></p><p>但单引号和双引号都可以使用”+”连接字符串,如<br><img src="/images/Gradle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01.png" alt="enter description here" title="Gradle学习笔记2.png"></p><h1 id="Groovy支持java的全部集合类"><a href="#Groovy支持java的全部集合类" class="headerlink" title="Groovy支持java的全部集合类"></a>Groovy支持java的全部集合类</h1><h2 id="List"><a href="#List" class="headerlink" title="List:"></a>List:</h2><p>声名定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def num = [1,2,3,4];//相当于java的List&lt;Interger&gt; num = new ArrayList()&lt;&gt;;</span><br></pre></td></tr></table></figure></p><p>使用时可像数组一样通过下标获取,正数为从0开始算,负数为从末尾开始算<br>num[0]为1    num[-1]为4    num[1..3]为访问1到3位置的数据<br>遍历list使用each<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">num.each&#123;</span><br><span class="line">println it//it为迭代元素</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>声名定义(看起来像键值对的数组):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def num = [&apos;width&apos;:1,&apos;height&apos;:2];</span><br></pre></td></tr></table></figure></p><p>使用时可使用num[‘width’]和num.width的方式来获取<br>遍历也是使用each,但其迭代的元素it为一个Entry实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">num.each&#123;</span><br><span class="line">println &quot;Key:$&#123;it.key&#125;,Value:$&#123;it.value&#125;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="Groovy的方法调用"><a href="#Groovy的方法调用" class="headerlink" title="Groovy的方法调用"></a>Groovy的方法调用</h1><p>Groocy的方法调用不需要括号如add(1,2)可为add 1,2<br>返回值不用return如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def add(int i,int j)&#123;</span><br><span class="line">i+j//此处作为最后一行执行,会被识别为返回的参数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="实体类bean"><a href="#实体类bean" class="headerlink" title="实体类bean"></a>实体类bean</h1><p>groovy的实体类不需要写get/set方法,在定义参数后,内部会自动有这样个方法,也意味着其外部可读可写,如果不定义参数,直接写get方法,那这个参数为外部只读<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Present&#123;</span><br><span class="line">private String name//定义字符串name,可读可写</span><br><span class="line"></span><br><span class="line">public int getAge()&#123;//定义int的age,只读</span><br><span class="line">12</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>方法传入的参数为一个代码块,在代码块的调用的方法可被指定优先调用那个对象的方法,也就是闭包委托.闭包的关键字为Closure,如上述使用的each传入的为代码块,其中就位闭包,而it为闭包的委托.</p><h2 id="单参数"><a href="#单参数" class="headerlink" title="单参数"></a>单参数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">task test&#123;</span><br><span class="line">customEach&#123;</span><br><span class="line">println it</span><br><span class="line">&#125;</span><br><span class="line">def customEach(closure)&#123;</span><br><span class="line">for(int i in 1..10)&#123;//遍历1到10</span><br><span class="line">closure(i)//相当于遍历一次就调用一次传进来的代码块,传入的i就为it的值</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多参数"><a href="#多参数" class="headerlink" title="多参数"></a>多参数</h2><p>而且通过闭包可传出多个参数,其实是传出了一个对象.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">task test&#123;</span><br><span class="line">eachMap&#123;k,v -&gt;//指定多个参数的代表</span><br><span class="line">println &quot;$&#123;k&#125;,$&#123;v&#125;&quot;</span><br><span class="line">&#125;</span><br><span class="line">def eachMap(closure)&#123;</span><br><span class="line"> def mapl = [&quot;a&quot;:1,&quot;b&quot;:2]</span><br><span class="line">mapl.each&#123;</span><br><span class="line">closure(it.key,it.value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="闭包委托"><a href="#闭包委托" class="headerlink" title="闭包委托"></a>闭包委托</h2><p>闭包中有3个关键字(属性),thisObject(相当于Android的this),owner,delegate,默认下owner和delegate相等,但delegate可被更改,更改后会方法块中的调用会调用其指向的对象.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">preson&#123;</span><br><span class="line">age = 10//此处相当于p.age = 10,p为闭包代理</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">def preson(Closure&lt;Person&gt; closure)&#123;</span><br><span class="line">Preson p = new Preson();</span><br><span class="line">closure.delegate = p</span><br><span class="line">closure.setResolveStrategy(Closure.DELEGATE_FIRST);//设置委托模式优先</span><br><span class="line">closure(p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="settings-gradle文件"><a href="#settings-gradle文件" class="headerlink" title="settings.gradle文件"></a>settings.gradle文件</h1><p>用于配置工程树,配置工程中要加入构建的工程/模块,并可设置对应工程的路径,不设置就默认为工程跟根路径.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">include &apos;:app&apos;</span><br><span class="line">include &apos;:test&apos;</span><br><span class="line"></span><br><span class="line">project(&apos;:test&apos;).projectDir = new File(&apos;test&apos;)//设置test工程的目录在./test中</span><br></pre></td></tr></table></figure></p><h1 id="build-gradle文件"><a href="#build-gradle文件" class="headerlink" title="build.gradle文件"></a>build.gradle文件</h1><p>每个工程都有一个build文件,用于配置构建时导入的插件或者配合构建参数,其为工程构建的入口,其中有一个根工程的build,在此文件中可统一配置所有子工程的配置.<br>其中allprojects和subprojects都是对子工程的配置,buildProject时对导入的工程的配置,如导入a模块,而a模块需要导入b模块.配置使用的方法基本都是用了闭包,所以也可以在配置的时候输出信息.</p><h1 id="任务依赖"><a href="#任务依赖" class="headerlink" title="任务依赖"></a>任务依赖</h1><p>在进行task时,有时需要不同任务会有依赖关系,所以存在谁前谁后的问题,(关键字dependsOn)如a依赖于b,所以b要先执行完a才执行,如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">task b&#123;</span><br><span class="line">xxx</span><br><span class="line">&#125;</span><br><span class="line">task a(dependsOn b)&#123;</span><br><span class="line">xxxxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上任务,a会等b运行完了再运行<br>也可以依赖多个任务,如a依赖b,c任务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">task c&#123;</span><br><span class="line">xxx</span><br><span class="line">&#125;</span><br><span class="line">task b&#123;</span><br><span class="line">xxx</span><br><span class="line">&#125;</span><br><span class="line">task a&#123;</span><br><span class="line">dependsOn c,b</span><br><span class="line">xxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>每个任务在project中都为一个属性,所以可以调用这个属性如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">c.doLast&#123;</span><br><span class="line">xxx</span><br><span class="line">&#125;</span><br><span class="line">c.doFirst&#123;</span><br><span class="line">xxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此处调用了c的两个方法,他们的first和last时在c任务运行后的</p><h1 id="自定义prohect属性"><a href="#自定义prohect属性" class="headerlink" title="自定义prohect属性"></a>自定义prohect属性</h1><p>使用ext来自定义属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ext age = 5//定义一个属性</span><br><span class="line"></span><br><span class="line">ext &#123;//定义多个属性</span><br><span class="line">name = &apos;666&apos;</span><br><span class="line">address = &apos;你很棒&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>定义的属性相当于全局变量</p><h1 id="任务分组和描述"><a href="#任务分组和描述" class="headerlink" title="任务分组和描述"></a>任务分组和描述</h1><p>分组即描述是为了更好的管理这些任务<br>task.group = BasePlugin.BUID_GROUP//将任务分组到BUID_GROUP中<br>task.description = ‘测试用的’//添加任务描述,说明任务的作用</p><h1 id="任务的执行"><a href="#任务的执行" class="headerlink" title="任务的执行"></a>任务的执行</h1><p>每个任务内都有一个List列表,保存的就是任务要执行的action,所以doFirst和doLast是对List添加action在列表的头部或尾部,然后从头到尾执行,这里还有和doSelf是中间,也是任务本身.<br>可以用任务排序来控制任务的执行顺序,听说这个为base版,后期可能更改<br>task.shouldRunAfter(task2)//task建议在task2之后执行,这个用处不大,实际运行可能会也可能不会<br>task.mustRunAfter(task2)//task一定在task2之后执行</p><h1 id="任务启用"><a href="#任务启用" class="headerlink" title="任务启用"></a>任务启用</h1><p>任务中有个enabled参数,用于控制任务是否启用,默认为true启用,设置为false是不执行,并提示跳过此任务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">task not&#123;</span><br><span class="line">xzxxx</span><br><span class="line">&#125;</span><br><span class="line">not.enabled = false</span><br></pre></td></tr></table></figure></p><h1 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h1><p>groovy中除了可以使用if else来断言,还提供了onlyIf,其作用于任务的条件执行,onlyIf接收一个方法块的返回值,true则执行此任务,否则不执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">task.onlyIf&#123;</span><br><span class="line">Object build = project.property(&quot;build&quot;)</span><br><span class="line">if(build.equals(&quot;666&quot;))&#123;</span><br><span class="line">true</span><br><span class="line">&#125;</span><br><span class="line">false</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上任务开启时使用命令传入build参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew -p build=666 :task</span><br></pre></td></tr></table></figure></p><h1 id="任务规则"><a href="#任务规则" class="headerlink" title="任务规则"></a>任务规则</h1><p>在gradle任务执行出现错误,无法识别该任务或找不到时,会调用这个规则.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">addRule(&quot;测试规则&quot;)&#123;</span><br><span class="line">String taskName-&gt;</span><br><span class="line">task(taskName)&#123;</span><br><span class="line">println &quot;测试出现个提示&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">findByName(&quot;666&quot;)//查找时,出现无此任务时会触发规则,发出提示</span><br></pre></td></tr></table></figure></p><h1 id="gradle插件"><a href="#gradle插件" class="headerlink" title="gradle插件"></a>gradle插件</h1><h2 id="应用二进制插件"><a href="#应用二进制插件" class="headerlink" title="应用二进制插件"></a>应用二进制插件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply plugin:a//应用a插件,这里的a建议用全限定名</span><br></pre></td></tr></table></figure><h2 id="脚本插件"><a href="#脚本插件" class="headerlink" title="脚本插件"></a>脚本插件</h2><p>将脚本加载到本gradle中<br>build.gradle<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply from:&apos;a&apos;</span><br></pre></td></tr></table></figure></p><p>a.gradle<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ext&#123;</span><br><span class="line">version = &apos;1.0.0&apos;</span><br><span class="line">name = &apos;test&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>相当于build中就有了a中的参数</p><p>apply也可使用闭包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">apply &#123;</span><br><span class="line">plugin :xxx</span><br><span class="line">plugin : xxx</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="应用第三方插件"><a href="#应用第三方插件" class="headerlink" title="应用第三方插件"></a>应用第三方插件</h2><p>在应用二进制第三方插件时,需要配置buildscript中的dependencies中的classpath,指定使用的gradle版本.若此插件被官网托管了就可以不用设置.<br><img src="/images/Gradle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01.png" alt="enter description here" title="Gradle学习笔记3.png"></p><h2 id="依赖第三方"><a href="#依赖第三方" class="headerlink" title="依赖第三方"></a>依赖第三方</h2><p>compile 编译时依赖<br>runtime 运行时依赖<br>testCompile 编译测试时依赖,打包不会依赖进去<br>testRuntime 运行测试时依赖<br>archives 项目发布构建(jar)依赖<br>default 默认依赖</p><p>也可以指定一个源集依赖<br>mainCompile   //main源集依赖</p><p>compile project(‘:a’)//依赖a工程<br>compile files(‘libs/a.jar’)//依赖jar包<br>compile fileTree(dir:’libs’,include:’*.jar’)//依赖libs目录下所有jar包</p><h2 id="源集"><a href="#源集" class="headerlink" title="源集"></a>源集</h2><p>sourceSets,用于设置资源的配置,如资源所在的路径和编译后的路径<br>其中的属性<br>name//只读,如main<br>output.classesDir//指定源集编译后的class目录<br>output.resourcess//指定源集编译后生成的资源目录<br>compileClasspath//编译指定源集时所需的classpath<br>java//指定源集java源文件<br>java.srcDirs//指定源集java源文件所在目录<br>resources//指定源集的资源文件<br>resources.secDirs//指定源集的资源文件目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sourceSets&#123;</span><br><span class="line">main&#123;</span><br><span class="line">java&#123;</span><br><span class="line">scrDir &apos;src/java&apos; // 设置main源集的java源文件的目录</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/Gradle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01.png" alt="enter description here" title="Gradle学习笔记4.png"></p><p><img src="/images/Gradle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01.png" alt="enter description here" title="Gradle学习笔记5.png"></p><h1 id="Android的Gradle"><a href="#Android的Gradle" class="headerlink" title="Android的Gradle"></a>Android的Gradle</h1><h2 id="各属性"><a href="#各属性" class="headerlink" title="各属性"></a>各属性</h2><p>compileSdkVersion//编译的androidSDK版本,可为int或String<br>BuildToosVersion//构建版本,23.0.1<br>defaultConfig//默认配置,配置生产模式,多渠道打包<br>buildTypes//配置源文件资源文件,混淆,文件目录</p><h3 id="defaultConfig配置"><a href="#defaultConfig配置" class="headerlink" title="defaultConfig配置"></a>defaultConfig配置</h3><p>applicationId//指定生成的报名,默认为null,会从manifest中读取<br>minSdkVersion//App支持的最低Android版本<br>targetSdkVersion//App是基于那个android版本开发的,默认为null,会从manifest读取<br>versionCode//App内部版本,给内部人员看的<br>versionName//与versionCode类似,但其是给用户看的外部版本<br>testApplicationId//测试App的包名,一般使用默认的,applicationId+’test’<br>testInstructionRunner//配置单元测试使用的Runner,默认为android.test.InstrumentationTestRunner<br>proguardFile//设置一个混淆文件<br>proguardFiles//设置多个混淆文件<br>signingConfig//配置签名信息<br>signingConfigs//配置多个签名信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">android&#123;</span><br><span class="line">compileSdkVersion 23</span><br><span class="line">buildToolsVersion &quot;23.0.1&quot;</span><br><span class="line"></span><br><span class="line">signingConfigs&#123;</span><br><span class="line">release&#123;//正式版</span><br><span class="line">storeFile file(&quot;myreleasekey.keystore&quot;)//设置签名文件</span><br><span class="line">storePassword &quot;password&quot;//签名的store密码</span><br><span class="line">keyAlias &quot;Alias&quot;//签名的Alias</span><br><span class="line">keyPassword &quot;password&quot;//签名的key密码</span><br><span class="line">&#125;</span><br><span class="line">debug&#123;//debug版</span><br><span class="line">....</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">defaultConfig&#123;</span><br><span class="line">applicationId &quot;cn.com.lewis_v.test&quot;</span><br><span class="line">minSdkVersion 14</span><br><span class="line">targetSdkVersion 23</span><br><span class="line">versionCode 1</span><br><span class="line">versionName &quot;1.0.1&quot;</span><br><span class="line">//signingConfig signingConfigs.debug//使用Debug签名</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">buildTypes&#123;</span><br><span class="line">release&#123;</span><br><span class="line">signingConfig signingConfigs.release//此处也能设置签名</span><br><span class="line">&#125;</span><br><span class="line">debug&#123;</span><br><span class="line">signingConfig.signingConfigs.debug</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="buildTypes配置"><a href="#buildTypes配置" class="headerlink" title="buildTypes配置"></a>buildTypes配置</h3><p>applicationIdSuffix//配置applicationId的后缀,相当于改包名了<br>debuggable//配置生成的apk是否可调试<br>jniDebuggable//配置生成的apk是否可进行jni调试<br>minifyEnabled//是否启用混淆<br>multiDexEnabled//是否启用分包,方法超过65535时需要拆分多个包<br>proguardFile//配置混淆文件<br>proguardFile//配置多个混淆文件<br>shrinkResources//是否自动清理未使用的资源,默认false<br>signingConfig//配置签名信息<br>testFunctionalTest//是否为功能测试<br>testHandleProfiling//是否启用分析功能<br>useJack//是否启用,新的编译器,这个编译器更快,但是目前还不成熟</p><p>可以看到buildTypes和defaultConfig有些属性重复了,但一般默认配置在前,然后在buildType中根据不同渠道去修改相关属性,未设置的就是用默认配置</p><h3 id="zipalign优化"><a href="#zipalign优化" class="headerlink" title="zipalign优化"></a>zipalign优化</h3><p>android提供的整理优化apk的工具,可提高运行效率,降低内存使用,使用方法很简单<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">android&#123;</span><br><span class="line">buildTypes&#123;</span><br><span class="line">release&#123;</span><br><span class="line">zipAlignEnabled true//启用zipAlign</span><br><span class="line">&#125;</span><br><span class="line">debug&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="使用共享库"><a href="#使用共享库" class="headerlink" title="使用共享库"></a>使用共享库</h1><p>如在6.0之后httpClient被删除了,要使用的话需要手动添加共享库,build.gradle中为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">android&#123;</span><br><span class="line">useLibrary(&apos;org.apache.http.legacy&apos;)</span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>manifest.xml,这里不写不会出错<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-library</span><br><span class="line">android:name=&quot;org.apache.http.legacy&quot;</span><br><span class="line">android:required=&quot;true&quot;</span><br></pre></td></tr></table></figure></p><h1 id="gradle中使用命令行"><a href="#gradle中使用命令行" class="headerlink" title="gradle中使用命令行"></a>gradle中使用命令行</h1><p>gradle提供了exec来执行shell命令,<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def stdout = new ByteArrayOutputStream()</span><br><span class="line">exec&#123;</span><br><span class="line">commandLine &apos;git&apos;,&apos;tag&apos;,&apos;--list&apos;</span><br><span class="line">standardOutput = stdout//获取命令执行的返回</span><br><span class="line">&#125;</span><br><span class="line">return stdout.toString()</span><br></pre></td></tr></table></figure></p><h1 id="动态设置Manifest"><a href="#动态设置Manifest" class="headerlink" title="动态设置Manifest"></a>动态设置Manifest</h1><p>可使用Gradle动态替换manifest中${}占位符<br>manifest.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta-data android:value=&quot;$&#123;TEST&#125;&quot; android:name=&quot;test&quot;/&gt;</span><br></pre></td></tr></table></figure></p><p>在gradle中使用manifestPlaceholders来替换<br>gradle<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">productFlavors&#123;</span><br><span class="line">google&#123;</span><br><span class="line">manifestPlaceholders.put(&quot;TEST&quot;,&quot;google&quot;)</span><br><span class="line">&#125;</span><br><span class="line">baidu&#123;</span><br><span class="line">manifestPlaceholders.put(&quot;TEST&quot;,&quot;baidu&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可使用遍历所有productFlavors来替换,这样可能没那么灵活,但是对于很多渠道且不通点可在productFlavors中获取的时候,使用会很方便<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">productFlavors.all&#123;</span><br><span class="line">google&#123;</span><br><span class="line">&#125;</span><br><span class="line">baidu&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">productFlavors.all&#123;flavor-&gt;</span><br><span class="line">manifestPlaceholders.put(&quot;TEST&quot;,name)//此处的那么是闭包名/任务名,也就是上面的google和baidu</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="BuildConfig"><a href="#BuildConfig" class="headerlink" title="BuildConfig"></a>BuildConfig</h1><p>BuildConfig中包含了基本版本信息,如版本号,渠道,是否为DEBUG模式,其不可修改,而且是自动生成的</p><p>如平常获取包名使用context.getPackageName(),这里面实现较为复杂,性能不高,而使用BuildConfig.APPLICATION_ID获取到的就很方便,且其为一个全局的静态变量,获取的性能高</p><p>而其中的BuildConfig.DEBUG,标记是否为DEBUG模式,是则为true,不是则为false</p><p>当然也可以在构建的时候向BuildConfig加入我们自定义的参数,格式为:<br>BuildConfigField ‘type’,’name’,’value’//依次为类型,参数名,参数值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">buildTypes&#123;</span><br><span class="line">release&#123;</span><br><span class="line">BuildConfigField &apos;String&apos;,&apos;HOST&apos;,&apos;&quot;http://www.baidu.com&quot;&apos;</span><br><span class="line">&#125;</span><br><span class="line">debug&#123;</span><br><span class="line">BuildConfigField &apos;String&apos;,&apos;HOST&apos;,&apos;&quot;http://www.google.com&quot;&apos;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样,在正式包下,BuildConfig.HOST的值为baidu的,测试包下为google,这里需要注意的是参数值为String的需要有双引号’”xxxx”‘,如果写成了’xxx’,会出错,原因是他在文件中会写成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static final String HOST = www.baidu.com;//这样会出错,因为后面的不会被识别为字符串</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static final String HOST = &quot;www.baidu.com&quot;;//这样才是正确的</span><br></pre></td></tr></table></figure><h1 id="自定义资源文件的内容"><a href="#自定义资源文件的内容" class="headerlink" title="自定义资源文件的内容"></a>自定义资源文件的内容</h1><p>一般使用的资源文件,如string.xml,color.xml等,都可以在gradle中动态修改,在buildTypes和productFlavors中都可以修改<br>使用resValue ‘type’,’name’,’value’//这里和BuildConfig类似,type为资源类型,如string,name是资源中的标识名字,value是要设置为什么值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">productFlavors&#123;</span><br><span class="line">google&#123;</span><br><span class="line">resValue &apos;string&apos;,&apos;app_name&apos;,&apos;google&apos;</span><br><span class="line">&#125;</span><br><span class="line">baidu&#123;</span><br><span class="line">resvalue &apos;string&apos;,&apos;app_name&apos;,&apos;baidu&apos;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述代码,可在不同渠道下,修改string.xml中的app_name的值</p><h1 id="JAVA编译选项"><a href="#JAVA编译选项" class="headerlink" title="JAVA编译选项"></a>JAVA编译选项</h1><p>为设置java编译的JDK版本,文件编码,在android{}中提供了compileOption来设置这些,其中只提供了三个属性encoding(编码格式),sourceCompatibility和targetCompatibility为JDK版本号<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">android&#123;</span><br><span class="line">compileOptions&#123;</span><br><span class="line">encoding = &apos;utf-8&apos;</span><br><span class="line">sourceCompatibility = JavaVersion.VERSION_1_8</span><br><span class="line">targetCompatibility = JavaVersion.VERSION_1_8</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="adb操作配置"><a href="#adb操作配置" class="headerlink" title="adb操作配置"></a>adb操作配置</h1><p>gradle中提供了对adb命令的配置,其中配置的属性为两个timeOutInMs(超时),installOptions(安装配置)<br>这个也是android{}中提供的adbOptions设置的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">android&#123;</span><br><span class="line">adbOptions&#123;</span><br><span class="line">timeOutInMs = 5*1000//5秒超时</span><br><span class="line">installOptions &apos;-r&apos;,&apos;-s&apos;//安装配置</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中timeOutInMs为adb命令反应超时,在指定时间内无反馈则视为超时,报错CommandRejectException<br>installOptions安装的命令配置,<br>-l:锁定该应用程序;<br>-r:强制安装;<br>-t:允许测试包;<br>-s:安装到SD卡上;<br>-d:允许降级安装;-<br>g:授予运行时权限;</p><h1 id="dex选项"><a href="#dex选项" class="headerlink" title="dex选项"></a>dex选项</h1><p>配置dex命令运行的选项<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">android&#123;</span><br><span class="line">javaMaxHeapSize &quot;2g&quot;//调用dx命令是,分配最大的堆内存,看电脑的配置</span><br><span class="line">incremental true//开启增量模式,默认为false</span><br><span class="line">jumboMode true//开启jumbo模式,用于突破65535方法数限制</span><br><span class="line">threadCount 2//运行dx命令时的线程数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="资源自动清理"><a href="#资源自动清理" class="headerlink" title="资源自动清理"></a>资源自动清理</h1><p>在工程中,会应用第三方资源或有自己的代码不使用的,所以在gradle中提供打包时不将无用资源打包的设置</p><h2 id="shrink"><a href="#shrink" class="headerlink" title="shrink"></a>shrink</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">android&#123;</span><br><span class="line">buildTypes&#123;</span><br><span class="line">release&#123;</span><br><span class="line">shrinkResources true//开启自动清理,默认为false</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开启很简单,但是其清理会清理未被引用的资源,但是有些使用反射的会识别不到,所以gradle提供了keep文件来设置不清理的文件,res/raw/keep.xml(不存在需要自己新建文件)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;resources xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">tools:keep=&quot;@layout/xxx*,@layout/xx&quot;</span><br><span class="line">tools:shrinkMode=&quot;safe&quot;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure></p><p>其中keep为不清理文件,支持*通配符,用逗号分隔文件<br>shrinkMode为清理模式,默认safe,一般用safe就好了</p><h2 id="resConfig"><a href="#resConfig" class="headerlink" title="resConfig"></a>resConfig</h2><p>resConfig可配置只需要什么资源<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">android&#123;</span><br><span class="line">defaultConfig&#123;</span><br><span class="line">resConfig &apos;zh&apos;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="修改发布的aar包"><a href="#修改发布的aar包" class="headerlink" title="修改发布的aar包"></a>修改发布的aar包</h1><p>修改发布的arr包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">android&#123;</span><br><span class="line">defaultPublishConfig &quot;dubug&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>发布多个arr包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">android&#123;</span><br><span class="line">publishNonDefault true//开启多个arr包</span><br><span class="line">&#125;</span><br><span class="line">dependencies&#123;</span><br><span class="line">flavo1Compile project(path:&apos;:lib1&apos;,configuration:&apos;flavor1Release&apos;)</span><br><span class="line">flavo2Compile project(path:&apos;:lib1&apos;,configuration:&apos;flavor2Release&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="Junit测试"><a href="#Junit测试" class="headerlink" title="Junit测试"></a>Junit测试</h1><p>这个好像也叫单元测试,针对纯java的测试<br>使用单元测试需要导入Junit依赖,不过一般工程都自动导入了.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    testImplementation &apos;junit:junit:4.12&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在java目录下有三个包,其中有一个为test的另两个为主程序和androidTest(这是android环境的测试)<br>test包下的就是单元测试方法的编辑<br>例如要测试一个自己的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class TestUtil &#123;</span><br><span class="line">    public String get()&#123;</span><br><span class="line">        return &quot;777&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在test中新建一个类用于单元测试MyTest.java,这个代码不会加入apk包中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import org.junit.Test;</span><br><span class="line">import static org.junit.Assert.*;</span><br><span class="line"></span><br><span class="line">public class MyTest &#123;</span><br><span class="line">    @Test</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        assertEquals(new TestUtil().get(),&quot;666&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中@Test为声名此方法为测试方法,声名后再单元测试的时候会调用此方法进行测试<br>还有assert系列方法,这里的assertEquals是判断两个参数是否相同,不同会有错误提示<br>在命令框使用 gradle test 进行单元测试,测试结果会在app/build/reports/tests/testDebugUnitTest/classes中已HTML的形式保存,这了一个测试类会生成一个HTML文件</p><h1 id="测试配置"><a href="#测试配置" class="headerlink" title="测试配置"></a>测试配置</h1><p>可配置测试结果数据的目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">android&#123;</span><br><span class="line">testOptions&#123;</span><br><span class="line">reportDir = &quot;$project.buildDir/app/report&quot;//$project.buildDir为工程更目录</span><br><span class="line">resultsDir = &quot;$project.buildDir/app/result&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="代码覆盖率"><a href="#代码覆盖率" class="headerlink" title="代码覆盖率"></a>代码覆盖率</h1><p>检测测试用例的覆盖率<br>需要在buildTypes中开启testCoverageEnabled,并导入jacoco<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">apply plugin: &apos;jacoco&apos;</span><br><span class="line">...</span><br><span class="line">android&#123;</span><br><span class="line">...</span><br><span class="line">buildTypes&#123;</span><br><span class="line">debug&#123;</span><br><span class="line">testCoverageEnabled true</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">jacoco&#123;</span><br><span class="line">    toolVersion = &quot;0.7.1.201405082137&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用命令进行测试 gradle createDebugCoverageReport<br>结果在app\build\reports\coverage\debug\index.html中</p><h1 id="Lint测试"><a href="#Lint测试" class="headerlink" title="Lint测试"></a>Lint测试</h1><p>检查哪些代码没被使用,哪些使用新API等,生成一个报告,告诉哪里需要优化.<br>在gradle中使用lintOptions进行配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">android&#123;</span><br><span class="line">lintOptions&#123;</span><br><span class="line">abortOnError true//发现错误是否退出构建</span><br><span class="line">absolutePaths false//错误的输出是否显示绝对路径,默认为相对路径</span><br><span class="line">check &apos;NewApi&apos;//设置需要检测哪些Lint检查,具体项目使用命令查看lint --list</span><br><span class="line">checkAllWarning true//是否检测所有警告的issue</span><br><span class="line">checkReleaseBuilds true//在release中是否检测致命错误,出现错误终止构建</span><br><span class="line">disable &apos;NewApi&apos;//关闭哪些issue检查</span><br><span class="line">enable &apos;NewApi&apos;//开启哪些检查</span><br><span class="line">explainIssues true//错误报告是否包含解释说明</span><br><span class="line">htmlOutput new File(&quot;xxx&quot;)//配置Html报告的输出路径</span><br><span class="line">htmlReport true//是否生成html报告</span><br><span class="line">ignoreWarnings false//是否忽略警告级别的检查</span><br><span class="line">lintConfig new File(&quot;xxx&quot;)//指定Lint的配置文件,一个Xml文件</span><br><span class="line">noLines true//错误信息中,是否不包含源代码中的行号</span><br><span class="line">quiet false//是否安静模式,安静模式不会显示分析进度</span><br><span class="line">severityOverrides//返回一个Map结果,内容为个issue的优先级</span><br><span class="line">showAll true//是否显示全部输出,不为true,较长的信息会被截断</span><br><span class="line">textOutput new File(&quot;xxx&quot;)//生成text报告的路径</span><br><span class="line">textReport false//是否生成text报告</span><br><span class="line">warningAsErrors false//所有警告是否当成错误处理</span><br><span class="line">xmlOutput new File(&quot;xxx&quot;)//xml报告输出路径</span><br><span class="line">xmlReport true//是否生成xml报告</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="本笔记是学习《Android-Gradle-权威指南》作的笔记，当中有些内容可能错误或描述不清晰的，敬请谅解"><a href="#本笔记是学习《Android-Gradle-权威指南》作的笔记，当中有些内容可能错误或描述不清晰的，敬请谅解" class="headerlink" title="本笔记是学习《Android Gradle 权威指南》作的笔记，当中有些内容可能错误或描述不清晰的，敬请谅解~~"></a>本笔记是学习《Android Gradle 权威指南》作的笔记，当中有些内容可能错误或描述不清晰的，敬请谅解~~</h3>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>自定义YCardLayout</title>
      <link href="/2018/04/18/%E8%87%AA%E5%AE%9A%E4%B9%89YCardLayout/"/>
      <url>/2018/04/18/%E8%87%AA%E5%AE%9A%E4%B9%89YCardLayout/</url>
      <content type="html"><![CDATA[<p>这是一个卡片式滑动的控件<br><a id="more"></a><br>屁话不多说，先上个效果图先<br><img src="/images/YCardLayout.gif" alt="效果图1" title="效果图1"></p><p>将此控件放到RecyclerView中，并自定义LayoutManager可以有这样的效果<br><img src="/images/YCardLayout2.gif" alt="效果图2" title="效果图2"></p><p>github：<a href="https://github.com/lewis-v/YCardLayout" target="_blank" rel="noopener">https://github.com/lewis-v/YCardLayout</a></p><h1 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h1><h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><p>Add it in your root build.gradle at the end of repositories:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">allprojects &#123;</span><br><span class="line">repositories &#123;</span><br><span class="line">...</span><br><span class="line">maven &#123; url &apos;https://jitpack.io&apos; &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Add the dependency<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">        compile &apos;com.github.lewis-v:YCardLayout:1.0.1&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="在布局中使用"><a href="#在布局中使用" class="headerlink" title="在布局中使用"></a>在布局中使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;com.lewis_v.ycardlayoutlib.YCardLayout</span><br><span class="line">      android:id=&quot;@+id/fl&quot;</span><br><span class="line">      android:layout_marginTop=&quot;20dp&quot;</span><br><span class="line">      app:layout_constraintLeft_toLeftOf=&quot;parent&quot;</span><br><span class="line">      app:layout_constraintRight_toRightOf=&quot;parent&quot;</span><br><span class="line">      android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">      android:layout_height=&quot;wrap_content&quot;&gt;</span><br><span class="line">      &lt;ImageView</span><br><span class="line">          android:id=&quot;@+id/img&quot;</span><br><span class="line">          android:layout_margin=&quot;5dp&quot;</span><br><span class="line">          android:src=&quot;@mipmap/ic_launcher&quot;</span><br><span class="line">          android:layout_width=&quot;200dp&quot;</span><br><span class="line">          android:layout_height=&quot;200dp&quot; /&gt;</span><br><span class="line">  &lt;/com.lewis_v.ycardlayoutlib.YCardLayout&gt;</span><br></pre></td></tr></table></figure><h2 id="代码中进行操作"><a href="#代码中进行操作" class="headerlink" title="代码中进行操作"></a>代码中进行操作</h2><p>控件中已有默认的配合参数,所以可以直接使用,不进行配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">yCardLayout = findViewById(R.id.fl);</span><br><span class="line">        //yCardLayout.setMaxWidth(yCardLayout.getWidth());//设置最大移动距离</span><br><span class="line">        //yCardLayout.setMoveRotation(45);//最大旋转角度</span><br><span class="line">        //yCardLayout.reset();//重置数据</span><br><span class="line"></span><br><span class="line">        img = findViewById(R.id.img);</span><br><span class="line">        img.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(View v) &#123;</span><br><span class="line">                yCardLayout.removeToLeft(null);</span><br><span class="line">                Toast.makeText(MainActivity.this,&quot;点击11&quot;,Toast.LENGTH_SHORT).show();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></p><h1 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h1><h2 id="自定义控件继承于Framelayout及初始化"><a href="#自定义控件继承于Framelayout及初始化" class="headerlink" title="自定义控件继承于Framelayout及初始化"></a>自定义控件继承于Framelayout及初始化</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class YCardLayout extends FrameLayout &#123;</span><br><span class="line">public void init(Context context)&#123;</span><br><span class="line">        setClickable(true);</span><br><span class="line">        setEnabled(true);</span><br><span class="line">        minLength = ViewConfiguration.get(context).getScaledTouchSlop();//获取设备最小滑动距离</span><br><span class="line">        post(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                maxWidth = getWidth();//默认移动最大距离为控件的宽度,这里的参数用于旋转角度的变化做参照</span><br><span class="line">                firstPoint = new Point((int) getX(),(int)getY());//获取初始位置</span><br><span class="line">                isInit = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现移动的动画-还用移动时的旋转"><a href="#实现移动的动画-还用移动时的旋转" class="headerlink" title="实现移动的动画,还用移动时的旋转"></a>实现移动的动画,还用移动时的旋转</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">   public boolean onTouchEvent(MotionEvent event) &#123;</span><br><span class="line">       if (!isRemove &amp;&amp; moveAble &amp;&amp; isInit &amp;&amp; !isRunAnim) &#123;</span><br><span class="line">           switch (event.getAction()) &#123;</span><br><span class="line">               case MotionEvent.ACTION_DOWN:</span><br><span class="line">                   //获取点击时的数据,并存起来</span><br><span class="line">                   cacheX = event.getRawX();</span><br><span class="line">                   cacheY = event.getRawY();</span><br><span class="line">                   downX = event.getRawX();</span><br><span class="line">                   downY = event.getRawY();</span><br><span class="line">                   if (firstPoint == null) &#123;//这个正常情况不会执行,在这里只是以防万一</span><br><span class="line">                       firstPoint = new Point((int) getX(), (int) getY());</span><br><span class="line">                   &#125;</span><br><span class="line">                   return true;</span><br><span class="line">               case MotionEvent.ACTION_MOVE:</span><br><span class="line">                   if ((Math.abs(downX-event.getRawX()) &gt; minLength || Math.abs(downY-event.getRawY()) &gt; minLength)) &#123;//只有大于最小滑动距离才算移动了</span><br><span class="line">                       float moveX = event.getRawX();</span><br><span class="line">                       float moveY = event.getRawY();</span><br><span class="line"></span><br><span class="line">                       if (moveY &gt; 0) &#123;</span><br><span class="line">                           setY(getY() + (moveY - cacheY));//移动Y轴</span><br><span class="line">                       &#125;</span><br><span class="line">                       if (moveX &gt; 0) &#123;</span><br><span class="line">                           setX(getX() + (moveX - cacheX));//移动X轴</span><br><span class="line">                           float moveLen = (moveX - downX) / maxWidth;</span><br><span class="line">                           int moveProgress = (int) ((moveLen) * 100);//移动的距离占整个控件的比例moveProgress%</span><br><span class="line">                           setRotation((moveLen) * 45f);//控制控件的旋转</span><br><span class="line">                           if (onYCardMoveListener != null) &#123;</span><br><span class="line">                               onYCardMoveListener.onMove(this, moveProgress);//触发移动的监听器</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                       cacheX = moveX;</span><br><span class="line">                       cacheY = moveY;</span><br><span class="line">                   &#125;</span><br><span class="line">                   return false;</span><br><span class="line">               case MotionEvent.ACTION_UP:</span><br><span class="line">                   if ((Math.abs(downX-event.getRawX()) &gt; minLength || Math.abs(downY-event.getRawY()) &gt; minLength)) &#123;//移动了才截获这个事件</span><br><span class="line">                       int moveEndProgress = (int) (((event.getRawX() - downX) / maxWidth) * 100);</span><br><span class="line">                       if (onYCardMoveListener != null) &#123;</span><br><span class="line">                           if (onYCardMoveListener.onMoveEnd(this, moveEndProgress)) &#123;//移动结束事件</span><br><span class="line">                               return true;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                       animToReBack(this, firstPoint);//复位</span><br><span class="line">                       return true;</span><br><span class="line">                   &#125;</span><br><span class="line">                   break;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return false;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="加入移动后的复位动画"><a href="#加入移动后的复位动画" class="headerlink" title="加入移动后的复位动画"></a>加入移动后的复位动画</h2><p>上面的代码调用了animToReBack(this, firstPoint);来进行复位<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 复位动画</span><br><span class="line">     * @param view</span><br><span class="line">     * @param point 复位的位置</span><br><span class="line">     */</span><br><span class="line">    public void animToReBack(View view,Point point)&#123;</span><br><span class="line">        AnimatorSet animatorSet = getAnimToMove(view,point,0,getAlpha());//获取动画</span><br><span class="line">        isRunAnim = true;//动画正在运行的标记</span><br><span class="line">        animatorSet.addListener(new Animator.AnimatorListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onAnimationStart(Animator animation) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onAnimationEnd(Animator animation) &#123;</span><br><span class="line">                isRunAnim = false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onAnimationCancel(Animator animation) &#123;</span><br><span class="line">                isRunAnim = false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onAnimationRepeat(Animator animation) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        animatorSet.start();//开始复位动画</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>控件里的所有动画都通过getAnimToMove来获取,getAnimToMove的代码为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * 移动动画</span><br><span class="line">    * @param view</span><br><span class="line">    * @param point</span><br><span class="line">    * @param rotation</span><br><span class="line">    */</span><br><span class="line">   public AnimatorSet getAnimToMove(View view, Point point, float rotation,float alpha)&#123;</span><br><span class="line">       ObjectAnimator objectAnimatorX = ObjectAnimator.ofFloat(view,&quot;translationX&quot;,point.x);</span><br><span class="line">       ObjectAnimator objectAnimatorY = ObjectAnimator.ofFloat(view,&quot;translationY&quot;,point.y);</span><br><span class="line">       ObjectAnimator objectAnimatorR = ObjectAnimator.ofFloat(view,&quot;rotation&quot;,rotation);</span><br><span class="line">       ObjectAnimator objectAnimatorA = ObjectAnimator.ofFloat(view,&quot;alpha&quot;,alpha);</span><br><span class="line">       AnimatorSet animatorSet = new AnimatorSet();</span><br><span class="line">       animatorSet.playTogether(objectAnimatorR,objectAnimatorX,objectAnimatorY,objectAnimatorA);</span><br><span class="line">       return animatorSet;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>到这里,控件就可以移动和复位了,到了删除动画的实现了</p><h2 id="删除动画"><a href="#删除动画" class="headerlink" title="删除动画"></a>删除动画</h2><p>删除动画有左边的右边删除,删除的移动轨迹,需要与滑动方向相关,这样看起来的效果才比较好<br>这里写了两个方法,供删除时调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     *  向左移除控件</span><br><span class="line">     * @param removeAnimListener</span><br><span class="line">     */</span><br><span class="line">    public void removeToLeft(RemoveAnimListener removeAnimListener)&#123;</span><br><span class="line">        remove(true,removeAnimListener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 向右移除控件</span><br><span class="line">     * @param removeAnimListener</span><br><span class="line">     */</span><br><span class="line">    public void removeToRight(RemoveAnimListener removeAnimListener)&#123;</span><br><span class="line">        remove(false,removeAnimListener);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>其中remove方法实现为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 移除控件并notify</span><br><span class="line">     * @param isLeft 是否是向左</span><br><span class="line">     * @param removeAnimListener</span><br><span class="line">     */</span><br><span class="line">    public void remove(boolean isLeft, final RemoveAnimListener removeAnimListener)&#123;</span><br><span class="line">        isRemove = true;</span><br><span class="line">        final Point point = calculateEndPoint(this,this.firstPoint,isLeft);//计算终点坐标</span><br><span class="line">        AnimatorSet animatorSet = getReMoveAnim(this,point,getRemoveRotation(this,this.firstPoint,isLeft));//获取移除动画</span><br><span class="line">        animatorSet.addListener(new Animator.AnimatorListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onAnimationStart(Animator animation) &#123;</span><br><span class="line">                if (removeAnimListener != null)&#123;</span><br><span class="line">                    removeAnimListener.OnAnimStart(YCardLayout.this);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onAnimationEnd(Animator animation) &#123;</span><br><span class="line">                if (removeAnimListener != null)&#123;</span><br><span class="line">                    removeAnimListener.OnAnimEnd(YCardLayout.this);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onAnimationCancel(Animator animation) &#123;</span><br><span class="line">                Log.e(&quot;cancel&quot;,&quot;&quot;);</span><br><span class="line">                reset();</span><br><span class="line">                if (removeAnimListener != null)&#123;</span><br><span class="line">                    removeAnimListener.OnAnimCancel(YCardLayout.this);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onAnimationRepeat(Animator animation) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        animatorSet.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>在动画开始/结束/取消懂提供了回调,当然不需要时传入null就行了<br>其中调用计算终点坐标的方法,这个不好解释,看看计算过程,详细的就不说了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * 计算移除动画终点</span><br><span class="line">    * @param view</span><br><span class="line">    * @param point</span><br><span class="line">    * @param isLeft</span><br><span class="line">    * @return</span><br><span class="line">    */</span><br><span class="line">   public Point calculateEndPoint(View view, Point point, boolean isLeft)&#123;</span><br><span class="line">       Point endPoint = new Point();</span><br><span class="line">       if (isLeft) &#123;</span><br><span class="line">           endPoint.x = point.x - (int) (view.getWidth() * 1.5);</span><br><span class="line">       &#125;else &#123;</span><br><span class="line">           endPoint.x = point.x + (int) (view.getWidth() * 1.5);</span><br><span class="line">       &#125;</span><br><span class="line">        if (Math.abs(view.getX() - point.x) &lt; minLength &amp;&amp;Math.abs (view.getY()-point.y) &lt; minLength)&#123;//还在原来位置</span><br><span class="line">           endPoint.y = point.y + (int)(view.getHeight()*1.5);</span><br><span class="line">       &#125;else &#123;</span><br><span class="line">           int endY = getEndY(view,point);</span><br><span class="line">           if (isLeft) &#123;</span><br><span class="line">               endPoint.y = (int) view.getY() - endY;</span><br><span class="line">           &#125;else &#123;</span><br><span class="line">               endPoint.y = (int)view.getY() + endY;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return endPoint;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * 获取终点Y轴与初始位置Y轴的距离</span><br><span class="line">    * @param view</span><br><span class="line">    * @param point</span><br><span class="line">    * @return</span><br><span class="line">    */</span><br><span class="line">   public int getEndY(View view,Point point)&#123;</span><br><span class="line">       return (int) ((point.y-view.getY())/(point.x-view.getX())*1.5*view.getWidth());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>而移除的动画,内部其实也是调用了getAnimToMove(),只是传入的旋转度为当前的旋转度,且透明度变化结束为0</p><p>到这里控件已经可以有移除动画了,但是会发现控件内的子控件的点击事件没有了,所以这里需要解决点击事件的冲突</p><h2 id="解决点击事件冲突"><a href="#解决点击事件冲突" class="headerlink" title="解决点击事件冲突"></a>解决点击事件冲突</h2><p>需要在onInterceptTouchEvent中,对事件进行分发处理,在down和up不截获,在move中选择性截获<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">   public boolean onInterceptTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">       boolean intercepted = super.onInterceptTouchEvent(ev);</span><br><span class="line">       if (!isInit || isRunAnim)&#123;</span><br><span class="line">           return false;</span><br><span class="line">       &#125;</span><br><span class="line">       switch (ev.getAction())&#123;</span><br><span class="line">           case MotionEvent.ACTION_DOWN:</span><br><span class="line">               downX = ev.getRawX();</span><br><span class="line">               downY = ev.getRawY();</span><br><span class="line">               cacheX = ev.getRawX();</span><br><span class="line">               cacheY = ev.getRawY();</span><br><span class="line">               if (firstPoint == null)&#123;</span><br><span class="line">                   firstPoint = new Point((int) getX(),(int) getY());</span><br><span class="line">               &#125;</span><br><span class="line">               intercepted = false;</span><br><span class="line">               break;</span><br><span class="line">           case MotionEvent.ACTION_MOVE:</span><br><span class="line">               if ((Math.abs(downX-ev.getRawX()) &gt; minLength || Math.abs(downY-ev.getRawY()) &gt; minLength) &amp;&amp; !isRemove &amp;&amp; moveAble)&#123;</span><br><span class="line">                   intercepted = true;</span><br><span class="line">               &#125;else &#123;</span><br><span class="line">                   intercepted = false;</span><br><span class="line">               &#125;</span><br><span class="line">               break;</span><br><span class="line">           case MotionEvent.ACTION_UP:</span><br><span class="line">               intercepted = false;</span><br><span class="line">               break;</span><br><span class="line">       &#125;</span><br><span class="line">       return intercepted;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>到这里YCardLayout就基本结束了,接下来就是与RecyclerView的结合了,结合之前要加个重置方法,用于重置控件数据,因为RecyclerView有复用的功能,不重置会被其他本控件影响<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * 重置数据</span><br><span class="line">    */</span><br><span class="line">   public void reset()&#123;</span><br><span class="line">       if (firstPoint != null) &#123;</span><br><span class="line">           setX(firstPoint.x);</span><br><span class="line">           setY(firstPoint.y);</span><br><span class="line">       &#125;</span><br><span class="line">       isRemove = false;</span><br><span class="line">       moveAble = true;</span><br><span class="line">       setRotation(0);</span><br><span class="line">       setAlpha(1);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><h1 id="结合RecyclerView"><a href="#结合RecyclerView" class="headerlink" title="结合RecyclerView"></a>结合RecyclerView</h1><h2 id="自定义LayoutManager"><a href="#自定义LayoutManager" class="headerlink" title="自定义LayoutManager"></a>自定义LayoutManager</h2><p>当然这里的Manager只是做示范作用,实际中可能会出现问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">public class YCardLayoutManager extends RecyclerView.LayoutManager &#123;</span><br><span class="line">    public static final String TAG = &quot;YCardLayoutManager&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public RecyclerView.LayoutParams generateDefaultLayoutParams() &#123;</span><br><span class="line">        return new RecyclerView.LayoutParams(RecyclerView.LayoutParams.WRAP_CONTENT,</span><br><span class="line">                RecyclerView.LayoutParams.WRAP_CONTENT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) &#123;</span><br><span class="line">        if (getItemCount() == 0) &#123;//没有Item，界面空着吧</span><br><span class="line">            detachAndScrapAttachedViews(recycler);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (getChildCount() == 0 &amp;&amp; state.isPreLayout()) &#123;//state.isPreLayout()是支持动画的</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        detachAndScrapAttachedViews(recycler);</span><br><span class="line">        setChildren(recycler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setChildren(RecyclerView.Recycler recycler)&#123;</span><br><span class="line">        for (int i = getItemCount()-1; i &gt;= 0; i--) &#123;</span><br><span class="line">            View view = recycler.getViewForPosition(i);</span><br><span class="line">            addView(view);</span><br><span class="line">            measureChildWithMargins(view,0,0);</span><br><span class="line">            calculateItemDecorationsForChild(view,new Rect());</span><br><span class="line">            int width = getDecoratedMeasurementHorizontal(view);</span><br><span class="line">            int height = getDecoratedMeasurementVertical(view);</span><br><span class="line">            layoutDecoratedWithMargins(view,0,0,width,height);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取某个childView在水平方向所占的空间</span><br><span class="line">     *</span><br><span class="line">     * @param view</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public int getDecoratedMeasurementHorizontal(View view) &#123;</span><br><span class="line">        final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams)</span><br><span class="line">                view.getLayoutParams();</span><br><span class="line">        return getPaddingRight()+getPaddingLeft()+getDecoratedMeasuredWidth(view) + params.leftMargin</span><br><span class="line">                + params.rightMargin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取某个childView在竖直方向所占的空间</span><br><span class="line">     *</span><br><span class="line">     * @param view</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public int getDecoratedMeasurementVertical(View view) &#123;</span><br><span class="line">        final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams)</span><br><span class="line">                view.getLayoutParams();</span><br><span class="line">        return getPaddingTop()+getPaddingBottom()+getDecoratedMeasuredHeight(view) + params.topMargin</span><br><span class="line">                + params.bottomMargin;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后在RecyclerView中使用YCardLayoutManager加上YCardLayout就能有最开始第二个动图那样的效果,但这里主要是自定义YCardLayout,在与RecyclerView使用的时候还需要对YCardLayoutManager进行相应的修改.目前使用时,在添加数据时需要使用notifyDataSetChanged()来进行刷新,删除时需要使用notifyItemRemoved(position)和notifyDataSetChanged()一起刷新,不然可能出现问题.</p><h1 id="The-End"><a href="#The-End" class="headerlink" title="The End"></a>The End</h1><p>在自定义这个控件中,主要是解决了点击事件的冲突,移除动画的终点计算,还有其他的冲突问题,这里的与RecyclerView的结合使用,其中使用的LayoutManager还有一些问题,将在完善后再加入到GitHub中.最后推荐本书《Android开发艺术探索》,这书还是挺不错的,这里解决点击事件冲突的也是在此书中看来的…</p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>滚动广告栏,自动滚动ViewPager--FlowView</title>
      <link href="/2018/04/18/%E6%BB%9A%E5%8A%A8%E5%B9%BF%E5%91%8A%E6%A0%8F-%E8%87%AA%E5%8A%A8%E6%BB%9A%E5%8A%A8ViewPager-FlowView/"/>
      <url>/2018/04/18/%E6%BB%9A%E5%8A%A8%E5%B9%BF%E5%91%8A%E6%A0%8F-%E8%87%AA%E5%8A%A8%E6%BB%9A%E5%8A%A8ViewPager-FlowView/</url>
      <content type="html"><![CDATA[<p>  好久都没时间写博客了,我都忘了博客是什么样的了,这次刚好找了点时间回来写写,刚好把最近做的东西来分享给有需要的人~这次带来的时自动滚动的ViewPager,并且将封装了小圆点功能</p><a id="more"></a><h1 id="FlowView"><a href="#FlowView" class="headerlink" title="FlowView"></a>FlowView</h1><p>轮播ViewPager<br>此控件对ViewPager循环轮播的实现进行封装,适用于一种View轮播及多种不同的View一起轮播,功能可能还有不完善的地方,后期会逐步完善</p><h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">repositories &#123;</span><br><span class="line">maven &#123; url &apos;https://jitpack.io&apos; &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> dependencies &#123;</span><br><span class="line">compile &apos;com.github.lewis-v:FlowView:1.0.3&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="YWFlowViewPager-循环滚动控件"><a href="#YWFlowViewPager-循环滚动控件" class="headerlink" title="YWFlowViewPager 循环滚动控件"></a>YWFlowViewPager 循环滚动控件</h1><h2 id="布局添加"><a href="#布局添加" class="headerlink" title="布局添加"></a>布局添加</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;com.lewis_v.widget.viewflow.YWFlowViewPager</span><br><span class="line">       android:id=&quot;@+id/viewpager&quot;</span><br><span class="line">       android:layout_width=&quot;match_parent&quot;</span><br><span class="line">       android:layout_height=&quot;200dp&quot;/&gt;</span><br></pre></td></tr></table></figure><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">flowview.setFlowView(imageViews);//添加显示的控件列表</span><br><span class="line">flowview.setFlowTime(3000);//设置轮播间隔ms,默认为5秒</span><br><span class="line">flowview.start(true);//开始轮播</span><br><span class="line">//设置对每页的点击事件</span><br><span class="line">flowview.setOnPageClickListener(new YWFlowViewPager.OnPageClickListener() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onPageClick(View view, int position) &#123;</span><br><span class="line">        Log.i(TAG, String.valueOf(position));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>#YWFlowView 对循环滚动控件进一步封装,添加了滚动的小圆点</p><h2 id="布局添加-1"><a href="#布局添加-1" class="headerlink" title="布局添加"></a>布局添加</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;com.lewis_v.widget.viewflow.YWFlowView</span><br><span class="line">      android:id=&quot;@+id/viewpager&quot;</span><br><span class="line">      android:layout_width=&quot;match_parent&quot;</span><br><span class="line">      android:layout_height=&quot;200dp&quot;/&gt;</span><br></pre></td></tr></table></figure><h2 id="初始化-与YWVFlowViewPager一样"><a href="#初始化-与YWVFlowViewPager一样" class="headerlink" title="初始化(与YWVFlowViewPager一样)"></a>初始化(与YWVFlowViewPager一样)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">viewpager.addFlowView(imageView).addFlowView(imageView1)//添加显示View,也可使用setFlowViewList()设置View列表</span><br><span class="line">               .setPointGravity(Gravity.RIGHT)//小圆点的位置</span><br><span class="line">.setPointLayoutBackground(R.color.blue)//设置圆点布局的背景颜色</span><br><span class="line">.setPointLayoutHeight(400)//设置圆点布局的背景高度</span><br><span class="line">.setPointSize(20,20)//设置圆点大小,宽与高</span><br><span class="line">.setPointMargins(20)//设置圆点间隔</span><br><span class="line">//以上的设置都有相应的默认设置,一般不需要在进行配置</span><br><span class="line">.start(this,true);//开始滚动,this为context的引用,true为是否滚动</span><br></pre></td></tr></table></figure><h2 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h2><p> 在生命周期内调用对应方法,用于暂停与恢复轮播<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  public void onResume() &#123;</span><br><span class="line">      super.onResume();</span><br><span class="line">      viewpager.resume();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void onPause() &#123;</span><br><span class="line">      super.onPause();</span><br><span class="line">      viewpager.pause();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h2 id="来个动图明白点"><a href="#来个动图明白点" class="headerlink" title="来个动图明白点"></a>来个动图明白点</h2><p><img src="/images/YViewPager.gif" alt="效果图"><br>附上:github : <a href="https://github.com/lewis-v/FlowView" target="_blank" rel="noopener">https://github.com/lewis-v/FlowView</a></p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>木有结尾</p><h2 id="若有问题请向作者反馈-605788229-qq-com"><a href="#若有问题请向作者反馈-605788229-qq-com" class="headerlink" title="若有问题请向作者反馈:(605788229@qq.com)"></a>若有问题请向作者反馈:(<a href="mailto:605788229@qq.com" target="_blank" rel="noopener">605788229@qq.com</a>)</h2>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>EventBus事件总线的实现</title>
      <link href="/2018/04/18/EventBus%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
      <url>/2018/04/18/EventBus%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<p>Y事件总线:基于java的Observe和Observable实现的事件总线<br>github地址:<a href="https://github.com/lewis-v/YEventBus" target="_blank" rel="noopener">https://github.com/lewis-v/YEventBus</a><br><a id="more"></a></p><h1 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h1><h2 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h2><p>Add it in your root build.gradle at the end of repositories:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">repositories &#123;</span><br><span class="line">...</span><br><span class="line">maven &#123; url &apos;https://jitpack.io&apos; &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> Add the dependency<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">        compile &apos;com.github.lewis-v:YEventBus:1.0.0&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="使用方式-1"><a href="#使用方式-1" class="headerlink" title="使用方式"></a>使用方式</h2><p>定义事件类TestEvent2继承于IEvent,并注册事件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">YEventBus.getInstance().subscriber(TestEvent2.class, new YObserver&lt;TestEvent2&gt;() &#123;//订阅事件,处理的所在的线程与分发的线程一致</span><br><span class="line">            @Override</span><br><span class="line">            public void onSuccess(TestEvent2 event) &#123;</span><br><span class="line">                Log.i(TAG,event.toString());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onFail(Exception e) &#123;</span><br><span class="line">                Log.e(TAG,e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">YEventBus.getInstance().subscriber(TestEvent.class, new YMainThreadObserver&lt;TestEvent&gt;() &#123;//订阅事件,会在主线程中处理</span><br><span class="line">            @Override</span><br><span class="line">            public void onSuccess(TestEvent event) &#123;</span><br><span class="line">                Log.i(TAG,event.toString());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onFail(Exception e) &#123;</span><br><span class="line">                Log.e(TAG,e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></p><p>发布事件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">YEventBus.getInstance().postMainEvent(TestEvent.class,new TestEvent(TAG));//发布在主线程分发的事件</span><br><span class="line"></span><br><span class="line">YEventBus.getInstance().postEvent(TestEvent.class,new TestEvent(TAG));//发布在子线程分发的事件</span><br></pre></td></tr></table></figure></p><p>取消订阅<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">YEventBus.getInstance().unSubscriber(TestEvent.class,observer);//取消某事件下的某个订阅者的订阅</span><br><span class="line">YEventBus.getInstance().unSubscriberEvent(TestEvent.class);//取消TestEvent整个系列事件的订阅</span><br><span class="line">YEventBus.getInstance().unSubscriberAll();//取消所有事件的订阅</span><br></pre></td></tr></table></figure></p><h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><h2 id="Observable与Observer"><a href="#Observable与Observer" class="headerlink" title="Observable与Observer"></a>Observable与Observer</h2><p>首先是使用java的Observable,在发布事件时需要先setChanged()在进行发布,否者是发布不了的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class YObservable extends Observable &#123;</span><br><span class="line"></span><br><span class="line">    public &lt;T extends IEvent&gt; void postEvent(T data)&#123;</span><br><span class="line">        setChanged();</span><br><span class="line">        notifyObservers(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后是java的Observer,这里实现了OnGetEvent接口,主要是要在本来的Observer接口上加上成功与失败的调用方法,其中Observer接口需要实现updata方法,此方法是在事件分发时调用的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface OnGetEvent&lt;E extends IEvent&gt; extends Observer&#123;</span><br><span class="line">    void onSuccess(E event);</span><br><span class="line">    void onFail(Exception e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>YObserver控制了事件的实际处理及异常的获取<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public abstract class YObserver&lt;E extends IEvent&gt; implements OnGetEvent&lt;E&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void update(Observable o, Object arg) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            onSuccess((E) arg);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            onFail(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里除了提供YObserver,还提供了YMainThreadObserver,此Observer的事件处理会在主线程中进行,添加此类的意义是,可以再发布时指定在主线程,也可以在订阅的时候指定在主线程,当然在订阅的时候指定的优先级比发布的时候指定优先级高.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public abstract class YMainThreadObserver&lt;E extends IEvent&gt; implements OnGetEvent&lt;E&gt;&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void update(final Observable o, final Object arg) &#123;</span><br><span class="line">        ThreadSchedule.getMainHandle().post(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    onSuccess((E) arg);</span><br><span class="line">                &#125;catch (Exception e)&#123;</span><br><span class="line">                    onFail(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Observable管理类"><a href="#Observable管理类" class="headerlink" title="Observable管理类"></a>Observable管理类</h2><p>YObservableManager用于管理Observable,内部定义了ConcurrentHashMap来存储Observable,其键值为对应事件的Class,在订阅和取消订阅会对map进行插入或遍历<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">public class YObservableManager &#123;</span><br><span class="line">    private ConcurrentHashMap&lt;Class,YObservable&gt; mObservableMap;</span><br><span class="line">    private IEventHandle handle;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public YObservableManager() &#123;</span><br><span class="line">        mObservableMap = new ConcurrentHashMap&lt;&gt;();</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public YObservableManager(ConcurrentHashMap&lt;Class, YObservable&gt; mObservableMap) &#123;</span><br><span class="line">        this.mObservableMap = mObservableMap;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void init()&#123;</span><br><span class="line">        handle = new YEventHandle();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 设置自定义的事件分发处理</span><br><span class="line">     * @param handle</span><br><span class="line">     */</span><br><span class="line">    public void setHandle(IEventHandle handle) &#123;</span><br><span class="line">        this.handle = handle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 发布消息</span><br><span class="line">     * @param event</span><br><span class="line">     * @param &lt;T&gt;</span><br><span class="line">     */</span><br><span class="line">    public &lt;T extends IEvent&gt; void postEvent(Class&lt;T&gt; event,T data)&#123;</span><br><span class="line">        YObservable observables = mObservableMap.get(event);</span><br><span class="line">        if (handle == null)&#123;</span><br><span class="line">            init();</span><br><span class="line">        &#125;</span><br><span class="line">        handle.postEvent(observables,data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 发布主线程消息</span><br><span class="line">     * @param event</span><br><span class="line">     * @param &lt;T&gt;</span><br><span class="line">     */</span><br><span class="line">    public &lt;T extends IEvent&gt; void postMainEvent(Class&lt;T&gt; event,T data)&#123;</span><br><span class="line">        YObservable observables = mObservableMap.get(event);</span><br><span class="line">        if (handle == null)&#123;</span><br><span class="line">            init();</span><br><span class="line">        &#125;</span><br><span class="line">        handle.postMainEvent(observables,data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 订阅事件</span><br><span class="line">     * @param event</span><br><span class="line">     * @param observer</span><br><span class="line">     * @param &lt;T&gt;</span><br><span class="line">     */</span><br><span class="line">    public &lt;T extends IEvent&gt; void subscriber(Class&lt;T&gt; event,OnGetEvent&lt;T&gt; observer)&#123;</span><br><span class="line">        if (mObservableMap.containsKey(event))&#123;</span><br><span class="line">            mObservableMap.get(event).addObserver(observer);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            YObservable observable = new YObservable();</span><br><span class="line">            observable.addObserver(observer);</span><br><span class="line">            mObservableMap.put(event, observable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 解除订阅</span><br><span class="line">     * @param event</span><br><span class="line">     * @param observer</span><br><span class="line">     * @param &lt;T&gt;</span><br><span class="line">     */</span><br><span class="line">    public &lt;T extends IEvent&gt; void unSubscriber(Class&lt;T&gt; event,YObserver&lt;T&gt; observer)&#123;</span><br><span class="line">        if (mObservableMap.containsKey(event))&#123;</span><br><span class="line">            mObservableMap.get(event).deleteObserver(observer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 解除一个事件系列的订阅</span><br><span class="line">     * @param event</span><br><span class="line">     */</span><br><span class="line">    public void unSubscriberEvent(Class&lt;? extends IEvent&gt; event)&#123;</span><br><span class="line">        if (mObservableMap.containsKey(event)) &#123;</span><br><span class="line">            mObservableMap.get(event).deleteObservers();</span><br><span class="line">            mObservableMap.remove(event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 解除所有事件订阅</span><br><span class="line">     */</span><br><span class="line">    public void unSubscriberAll()&#123;</span><br><span class="line">        for (Map.Entry&lt;Class,YObservable&gt; entry : mObservableMap.entrySet())&#123;</span><br><span class="line">            YObservable value = entry.getValue();</span><br><span class="line">            if (value != null)&#123;</span><br><span class="line">                value.deleteObservers();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mObservableMap.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 释放资源</span><br><span class="line">     */</span><br><span class="line">    public void destroy()&#123;</span><br><span class="line">        handle.destroy();</span><br><span class="line">        handle = null;</span><br><span class="line">        unSubscriberAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="事件的发布"><a href="#事件的发布" class="headerlink" title="事件的发布"></a>事件的发布</h2><p>上述代码中,在发布消息的时候会调用IEventHandle的postEvent,其实际的实现为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">public class YEventHandle implements IEventHandle&#123;</span><br><span class="line">    private ExecutorService executorServiceHandle;//处理线程池</span><br><span class="line"></span><br><span class="line">    public YEventHandle() &#123;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line">    private void init()&#123;</span><br><span class="line">        executorServiceHandle = Executors.newFixedThreadPool(2*Runtime.getRuntime().availableProcessors());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 发布消息</span><br><span class="line">     * @param observable</span><br><span class="line">     * @param data</span><br><span class="line">     * @param &lt;T&gt;</span><br><span class="line">     * @throws InterruptedException</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public &lt;T extends IEvent&gt; void postEvent(YObservable observable, T data) &#123;</span><br><span class="line">        handle(observable,data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 发布主线程处理消息</span><br><span class="line">     * @param observable</span><br><span class="line">     * @param data</span><br><span class="line">     * @param &lt;T&gt;</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public &lt;T extends IEvent&gt; void postMainEvent(YObservable observable, T data) &#123;</span><br><span class="line">        handleInMain(observable,data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 处理</span><br><span class="line">     * @param observable</span><br><span class="line">     * @param data</span><br><span class="line">     * @param &lt;T&gt;</span><br><span class="line">     */</span><br><span class="line">    private &lt;T extends IEvent&gt;  void handle(final YObservable observable, final T data)&#123;</span><br><span class="line">        executorServiceHandle.execute(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                if (observable != null) &#123;</span><br><span class="line">                    observable.postEvent(data);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 在主线程处理</span><br><span class="line">     * @param observable</span><br><span class="line">     * @param data</span><br><span class="line">     * @param &lt;T&gt;</span><br><span class="line">     */</span><br><span class="line">    private &lt;T extends IEvent&gt;  void handleInMain(final YObservable observable, final T data)&#123;</span><br><span class="line">        executorServiceHandle.execute(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                if (observable != null) &#123;</span><br><span class="line">                    ThreadSchedule.getMainHandle().post(new Runnable() &#123;</span><br><span class="line">                        @Override</span><br><span class="line">                        public void run() &#123;</span><br><span class="line">                            observable.postEvent(data);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 释放资源</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void destroy() &#123;</span><br><span class="line">        executorServiceHandle.shutdownNow();</span><br><span class="line">        executorServiceHandle = null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>事件的分发处理,会在一个线程池里进行,线程池的大小为Cpu核心数的2倍,当事件过多时会在线程池的队列中等待,需要注意的是对事件的处理尽量不要做太耗时的任务,不然把线程池中的所有线程都阻塞了会导致整个事件总线阻塞,后面的时间将无法继续发布.</p><h2 id="小结结"><a href="#小结结" class="headerlink" title="小结结"></a>小结结</h2><p>Y事件总线的实现只要是使用了java的Observable和Observer,其内部也是使用一个Vector类保存Observer,在发布的时候,遍历这里列表进行发布,这也是设计模式中的观察与被观察者的模式.</p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Hello~</title>
      <link href="/2018/04/14/Hello/"/>
      <url>/2018/04/14/Hello/</url>
      <content type="html"><![CDATA[<pre><code>欢迎来到,Lewis_v 的博客,在这里你可以了解到我对编程的理解及我对编程的学习路程~~</code></pre>]]></content>
      
      
    </entry>
    
  
  
    
    <entry>
      <title></title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      <content type="html"><![CDATA[<h1 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h1><pre><code>刘一为,90后程序员,17年入行Android开发。热爱编程、热爱代码设计。</code></pre><p><img src="/images/%E6%8A%80%E8%83%BD%E7%86%9F%E7%BB%83%E5%BA%A6.png" alt="技能熟练度" title="技能熟练度"></p><h2 id="个人作品"><a href="#个人作品" class="headerlink" title="个人作品"></a>个人作品</h2><h2 id="公众号"><a href="#公众号" class="headerlink" title="公众号"></a>公众号</h2><p><img src="/images/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7_%E4%BA%8C%E7%BB%B4%E7%A0%81_small.jpg" alt="Y代码" title="Y代码"></p><h2 id="与我联系"><a href="#与我联系" class="headerlink" title="与我联系"></a>与我联系</h2><p> QQ/微信:605788229<br> Email:<a href="mailto:605788229@qq.com" target="_blank" rel="noopener">605788229@qq.com</a></p>]]></content>
    </entry>
    
    <entry>
      <title></title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      <content type="html"><![CDATA[<p>title: categories</p><h2 id="date-2018-04-15-07-38-38"><a href="#date-2018-04-15-07-38-38" class="headerlink" title="date: 2018-04-15 07:38:38"></a>date: 2018-04-15 07:38:38</h2>]]></content>
    </entry>
    
    <entry>
      <title></title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      <content type="html"><![CDATA[<p>title: tags</p><h2 id="date-2018-04-15-07-38-47"><a href="#date-2018-04-15-07-38-47" class="headerlink" title="date: 2018-04-15 07:38:47"></a>date: 2018-04-15 07:38:47</h2>]]></content>
    </entry>
    
  
</search>
