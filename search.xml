<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Android 语音录制及播放的处理---AudioH</title>
      <link href="/2018/04/18/Android-%E8%AF%AD%E9%9F%B3%E5%BD%95%E5%88%B6%E5%8F%8A%E6%92%AD%E6%94%BE%E7%9A%84%E5%A4%84%E7%90%86-AudioH/"/>
      <url>/2018/04/18/Android-%E8%AF%AD%E9%9F%B3%E5%BD%95%E5%88%B6%E5%8F%8A%E6%92%AD%E6%94%BE%E7%9A%84%E5%A4%84%E7%90%86-AudioH/</url>
      <content type="html"><![CDATA[<p>Android 语音录制及播放的处理,基于MediaPlayer(播放) 和MediaRecorder (录制)</p><p>github地址：<a href="https://github.com/lewis-v/AudioH" target="_blank" rel="noopener">https://github.com/lewis-v/AudioH</a><br><a id="more"></a></p><h2 id="实现功能"><a href="#实现功能" class="headerlink" title="实现功能"></a>实现功能</h2><p>1.实现Android语音录制的功能（目前封装只支持AMR格式）；</p><p>2.实现Android语音播放功能（听筒和扬声器播放）；</p><p>3.实现语音播放中，网络语音的缓存；</p><p>4.提供获取缓存大小和清理缓存的方法；</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><h3 id="1-导入依赖"><a href="#1-导入依赖" class="headerlink" title="1.导入依赖"></a>1.导入依赖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">repositories &#123;</span><br><span class="line">...</span><br><span class="line">maven &#123; url &apos;https://jitpack.io&apos; &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">        compile &apos;com.github.lewis-v:AudioH:1.0.0&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-录音"><a href="#2-录音" class="headerlink" title="2.录音"></a>2.录音</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">RecoderBuilder builder = new DefaultRecoderBuilder()</span><br><span class="line">               .setMAX_LENGTH(60*1000)//最大录音60秒</span><br><span class="line">               .setMIN_LENGTH(500)//最小录音0.5秒</span><br><span class="line">               .setSAMPLEING_RATE(200)//录音监听回调间隔，200ms回调一次</span><br><span class="line">               .setSaveFolderPath(Environment.getExternalStorageDirectory()+&quot;/record/&quot;);</span><br><span class="line">       AudioRecoderManager.getInstance()//获取单例</span><br><span class="line">               .setAudioRecoderData(builder.create())//设置自定义配置，已有默认的配置，可不用配置</span><br><span class="line">               .setAudioRecoderListener(new AudioRecoderListener() &#123;//设置监听</span><br><span class="line">                   @Override</span><br><span class="line">                   public void onStart() &#123;//开始播放</span><br><span class="line"></span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   @Override</span><br><span class="line">                   public void onStop(AudioRecoderData audioRecoderData) &#123;//停止/结束播放</span><br><span class="line">                       Log.e(TAG,audioRecoderData.getFilePath());</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   @Override</span><br><span class="line">                   public void onFail(Exception e, String msg) &#123;//录音时出现的错误</span><br><span class="line">                       e.printStackTrace();</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   @Override</span><br><span class="line">                   public void onCancel() &#123;//录音取消</span><br><span class="line"></span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   @Override</span><br><span class="line">                   public void onSoundSize(int level) &#123;//录音时声音大小的回调，分贝</span><br><span class="line">                       Log.e(TAG,&quot;level:&quot;+level);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;);</span><br><span class="line">               </span><br><span class="line"> AudioRecoderManager.getInstance().start(this);//开始录音</span><br><span class="line"> AudioRecoderManager.getInstance().stop(this);//结束录音</span><br></pre></td></tr></table></figure><h3 id="3-播放"><a href="#3-播放" class="headerlink" title="3.播放"></a>3.播放</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">AudioPlayManager.getInstance().init(this)//初始化播放</span><br><span class="line">                .setPlayListener(new AudioPlayListener() &#123;//设置播放监听</span><br><span class="line">            @Override</span><br><span class="line">            public void onPlay(String audioPath) &#123;//开始播放</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onProgress(int progress, int maxSize) &#123;//播放进度（未实现）</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onPause() &#123;//播放暂停（未实现）</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onStop() &#123;//停止播放</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onFail(Exception e, String msg) &#123;//播放时出错</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">   </span><br><span class="line">   AudioPlayManager.getInstance().play(&quot;http://39.108.236.30:47423/audio/UP699813445282012.amr&quot;</span><br><span class="line">                                ,this, AudioPlayMode.MEGAPHONE);//播放音频,放心这段音频是我朋友的声音。。嘻嘻</span><br></pre></td></tr></table></figure><h3 id="4-缓存获取及清理"><a href="#4-缓存获取及清理" class="headerlink" title="4.缓存获取及清理"></a>4.缓存获取及清理</h3><p>缓存清理的方法未做线程处理，是同步进行的方法，需要开发者自己开子线程调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Log.e(TAG, String.valueOf(AudioPlayManager.getInstance().getCacheSize(this)));//获取缓存大小</span><br><span class="line">Log.e(TAG, String.valueOf(AudioPlayManager.getInstance().clearCache(this)));//清除缓存，并返回清除的大小</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Android Gradle学习笔记</title>
      <link href="/2018/04/18/Android-Gradle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/04/18/Android-Gradle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>gradle使用的脚本语言是Groovy,Groovy完全兼容java<br><a id="more"></a></p><h1 id="DSL"><a href="#DSL" class="headerlink" title="DSL"></a>DSL</h1><p>DSL的意思是领域特定语言,即专注于一个领域的语言,而像java是一种通用全面的语言,而Gradle就是一门DSL,基于Groovy,专注于自动化构建.</p><h1 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h1><p>def 用于参数/方法的定义,定义可不用定义返回类型<br>&lt;&lt; 此符号队伍任务来说相当于doLast,将任务放到任务队列的队尾执行</p><h1 id="Groovy的字符串表示"><a href="#Groovy的字符串表示" class="headerlink" title="Groovy的字符串表示"></a>Groovy的字符串表示</h1><p>Groovy的单引号和双引号都表示字符串,但单引号不具有计算功能,双引号有,如</p><p><img src="/images/Gradle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01.png" alt="enter description here" title="Gradle学习笔记1.png"></p><p>但单引号和双引号都可以使用”+”连接字符串,如<br><img src="/images/Gradle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01.png" alt="enter description here" title="Gradle学习笔记2.png"></p><h1 id="Groovy支持java的全部集合类"><a href="#Groovy支持java的全部集合类" class="headerlink" title="Groovy支持java的全部集合类"></a>Groovy支持java的全部集合类</h1><h2 id="List"><a href="#List" class="headerlink" title="List:"></a>List:</h2><p>声名定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def num = [1,2,3,4];//相当于java的List&lt;Interger&gt; num = new ArrayList()&lt;&gt;;</span><br></pre></td></tr></table></figure></p><p>使用时可像数组一样通过下标获取,正数为从0开始算,负数为从末尾开始算<br>num[0]为1    num[-1]为4    num[1..3]为访问1到3位置的数据<br>遍历list使用each<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">num.each&#123;</span><br><span class="line">println it//it为迭代元素</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>声名定义(看起来像键值对的数组):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def num = [&apos;width&apos;:1,&apos;height&apos;:2];</span><br></pre></td></tr></table></figure></p><p>使用时可使用num[‘width’]和num.width的方式来获取<br>遍历也是使用each,但其迭代的元素it为一个Entry实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">num.each&#123;</span><br><span class="line">println &quot;Key:$&#123;it.key&#125;,Value:$&#123;it.value&#125;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="Groovy的方法调用"><a href="#Groovy的方法调用" class="headerlink" title="Groovy的方法调用"></a>Groovy的方法调用</h1><p>Groocy的方法调用不需要括号如add(1,2)可为add 1,2<br>返回值不用return如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def add(int i,int j)&#123;</span><br><span class="line">i+j//此处作为最后一行执行,会被识别为返回的参数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="实体类bean"><a href="#实体类bean" class="headerlink" title="实体类bean"></a>实体类bean</h1><p>groovy的实体类不需要写get/set方法,在定义参数后,内部会自动有这样个方法,也意味着其外部可读可写,如果不定义参数,直接写get方法,那这个参数为外部只读<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Present&#123;</span><br><span class="line">private String name//定义字符串name,可读可写</span><br><span class="line"></span><br><span class="line">public int getAge()&#123;//定义int的age,只读</span><br><span class="line">12</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>方法传入的参数为一个代码块,在代码块的调用的方法可被指定优先调用那个对象的方法,也就是闭包委托.闭包的关键字为Closure,如上述使用的each传入的为代码块,其中就位闭包,而it为闭包的委托.</p><h2 id="单参数"><a href="#单参数" class="headerlink" title="单参数"></a>单参数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">task test&#123;</span><br><span class="line">customEach&#123;</span><br><span class="line">println it</span><br><span class="line">&#125;</span><br><span class="line">def customEach(closure)&#123;</span><br><span class="line">for(int i in 1..10)&#123;//遍历1到10</span><br><span class="line">closure(i)//相当于遍历一次就调用一次传进来的代码块,传入的i就为it的值</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多参数"><a href="#多参数" class="headerlink" title="多参数"></a>多参数</h2><p>而且通过闭包可传出多个参数,其实是传出了一个对象.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">task test&#123;</span><br><span class="line">eachMap&#123;k,v -&gt;//指定多个参数的代表</span><br><span class="line">println &quot;$&#123;k&#125;,$&#123;v&#125;&quot;</span><br><span class="line">&#125;</span><br><span class="line">def eachMap(closure)&#123;</span><br><span class="line"> def mapl = [&quot;a&quot;:1,&quot;b&quot;:2]</span><br><span class="line">mapl.each&#123;</span><br><span class="line">closure(it.key,it.value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="闭包委托"><a href="#闭包委托" class="headerlink" title="闭包委托"></a>闭包委托</h2><p>闭包中有3个关键字(属性),thisObject(相当于Android的this),owner,delegate,默认下owner和delegate相等,但delegate可被更改,更改后会方法块中的调用会调用其指向的对象.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">preson&#123;</span><br><span class="line">age = 10//此处相当于p.age = 10,p为闭包代理</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">def preson(Closure&lt;Person&gt; closure)&#123;</span><br><span class="line">Preson p = new Preson();</span><br><span class="line">closure.delegate = p</span><br><span class="line">closure.setResolveStrategy(Closure.DELEGATE_FIRST);//设置委托模式优先</span><br><span class="line">closure(p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="settings-gradle文件"><a href="#settings-gradle文件" class="headerlink" title="settings.gradle文件"></a>settings.gradle文件</h1><p>用于配置工程树,配置工程中要加入构建的工程/模块,并可设置对应工程的路径,不设置就默认为工程跟根路径.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">include &apos;:app&apos;</span><br><span class="line">include &apos;:test&apos;</span><br><span class="line"></span><br><span class="line">project(&apos;:test&apos;).projectDir = new File(&apos;test&apos;)//设置test工程的目录在./test中</span><br></pre></td></tr></table></figure></p><h1 id="build-gradle文件"><a href="#build-gradle文件" class="headerlink" title="build.gradle文件"></a>build.gradle文件</h1><p>每个工程都有一个build文件,用于配置构建时导入的插件或者配合构建参数,其为工程构建的入口,其中有一个根工程的build,在此文件中可统一配置所有子工程的配置.<br>其中allprojects和subprojects都是对子工程的配置,buildProject时对导入的工程的配置,如导入a模块,而a模块需要导入b模块.配置使用的方法基本都是用了闭包,所以也可以在配置的时候输出信息.</p><h1 id="任务依赖"><a href="#任务依赖" class="headerlink" title="任务依赖"></a>任务依赖</h1><p>在进行task时,有时需要不同任务会有依赖关系,所以存在谁前谁后的问题,(关键字dependsOn)如a依赖于b,所以b要先执行完a才执行,如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">task b&#123;</span><br><span class="line">xxx</span><br><span class="line">&#125;</span><br><span class="line">task a(dependsOn b)&#123;</span><br><span class="line">xxxxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上任务,a会等b运行完了再运行<br>也可以依赖多个任务,如a依赖b,c任务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">task c&#123;</span><br><span class="line">xxx</span><br><span class="line">&#125;</span><br><span class="line">task b&#123;</span><br><span class="line">xxx</span><br><span class="line">&#125;</span><br><span class="line">task a&#123;</span><br><span class="line">dependsOn c,b</span><br><span class="line">xxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>每个任务在project中都为一个属性,所以可以调用这个属性如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">c.doLast&#123;</span><br><span class="line">xxx</span><br><span class="line">&#125;</span><br><span class="line">c.doFirst&#123;</span><br><span class="line">xxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此处调用了c的两个方法,他们的first和last时在c任务运行后的</p><h1 id="自定义prohect属性"><a href="#自定义prohect属性" class="headerlink" title="自定义prohect属性"></a>自定义prohect属性</h1><p>使用ext来自定义属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ext age = 5//定义一个属性</span><br><span class="line"></span><br><span class="line">ext &#123;//定义多个属性</span><br><span class="line">name = &apos;666&apos;</span><br><span class="line">address = &apos;你很棒&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>定义的属性相当于全局变量</p><h1 id="任务分组和描述"><a href="#任务分组和描述" class="headerlink" title="任务分组和描述"></a>任务分组和描述</h1><p>分组即描述是为了更好的管理这些任务<br>task.group = BasePlugin.BUID_GROUP//将任务分组到BUID_GROUP中<br>task.description = ‘测试用的’//添加任务描述,说明任务的作用</p><h1 id="任务的执行"><a href="#任务的执行" class="headerlink" title="任务的执行"></a>任务的执行</h1><p>每个任务内都有一个List列表,保存的就是任务要执行的action,所以doFirst和doLast是对List添加action在列表的头部或尾部,然后从头到尾执行,这里还有和doSelf是中间,也是任务本身.<br>可以用任务排序来控制任务的执行顺序,听说这个为base版,后期可能更改<br>task.shouldRunAfter(task2)//task建议在task2之后执行,这个用处不大,实际运行可能会也可能不会<br>task.mustRunAfter(task2)//task一定在task2之后执行</p><h1 id="任务启用"><a href="#任务启用" class="headerlink" title="任务启用"></a>任务启用</h1><p>任务中有个enabled参数,用于控制任务是否启用,默认为true启用,设置为false是不执行,并提示跳过此任务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">task not&#123;</span><br><span class="line">xzxxx</span><br><span class="line">&#125;</span><br><span class="line">not.enabled = false</span><br></pre></td></tr></table></figure></p><h1 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h1><p>groovy中除了可以使用if else来断言,还提供了onlyIf,其作用于任务的条件执行,onlyIf接收一个方法块的返回值,true则执行此任务,否则不执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">task.onlyIf&#123;</span><br><span class="line">Object build = project.property(&quot;build&quot;)</span><br><span class="line">if(build.equals(&quot;666&quot;))&#123;</span><br><span class="line">true</span><br><span class="line">&#125;</span><br><span class="line">false</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上任务开启时使用命令传入build参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew -p build=666 :task</span><br></pre></td></tr></table></figure></p><h1 id="任务规则"><a href="#任务规则" class="headerlink" title="任务规则"></a>任务规则</h1><p>在gradle任务执行出现错误,无法识别该任务或找不到时,会调用这个规则.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">addRule(&quot;测试规则&quot;)&#123;</span><br><span class="line">String taskName-&gt;</span><br><span class="line">task(taskName)&#123;</span><br><span class="line">println &quot;测试出现个提示&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">findByName(&quot;666&quot;)//查找时,出现无此任务时会触发规则,发出提示</span><br></pre></td></tr></table></figure></p><h1 id="gradle插件"><a href="#gradle插件" class="headerlink" title="gradle插件"></a>gradle插件</h1><h2 id="应用二进制插件"><a href="#应用二进制插件" class="headerlink" title="应用二进制插件"></a>应用二进制插件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply plugin:a//应用a插件,这里的a建议用全限定名</span><br></pre></td></tr></table></figure><h2 id="脚本插件"><a href="#脚本插件" class="headerlink" title="脚本插件"></a>脚本插件</h2><p>将脚本加载到本gradle中<br>build.gradle<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply from:&apos;a&apos;</span><br></pre></td></tr></table></figure></p><p>a.gradle<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ext&#123;</span><br><span class="line">version = &apos;1.0.0&apos;</span><br><span class="line">name = &apos;test&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>相当于build中就有了a中的参数</p><p>apply也可使用闭包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">apply &#123;</span><br><span class="line">plugin :xxx</span><br><span class="line">plugin : xxx</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="应用第三方插件"><a href="#应用第三方插件" class="headerlink" title="应用第三方插件"></a>应用第三方插件</h2><p>在应用二进制第三方插件时,需要配置buildscript中的dependencies中的classpath,指定使用的gradle版本.若此插件被官网托管了就可以不用设置.<br><img src="/images/Gradle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01.png" alt="enter description here" title="Gradle学习笔记3.png"></p><h2 id="依赖第三方"><a href="#依赖第三方" class="headerlink" title="依赖第三方"></a>依赖第三方</h2><p>compile 编译时依赖<br>runtime 运行时依赖<br>testCompile 编译测试时依赖,打包不会依赖进去<br>testRuntime 运行测试时依赖<br>archives 项目发布构建(jar)依赖<br>default 默认依赖</p><p>也可以指定一个源集依赖<br>mainCompile   //main源集依赖</p><p>compile project(‘:a’)//依赖a工程<br>compile files(‘libs/a.jar’)//依赖jar包<br>compile fileTree(dir:’libs’,include:’*.jar’)//依赖libs目录下所有jar包</p><h2 id="源集"><a href="#源集" class="headerlink" title="源集"></a>源集</h2><p>sourceSets,用于设置资源的配置,如资源所在的路径和编译后的路径<br>其中的属性<br>name//只读,如main<br>output.classesDir//指定源集编译后的class目录<br>output.resourcess//指定源集编译后生成的资源目录<br>compileClasspath//编译指定源集时所需的classpath<br>java//指定源集java源文件<br>java.srcDirs//指定源集java源文件所在目录<br>resources//指定源集的资源文件<br>resources.secDirs//指定源集的资源文件目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sourceSets&#123;</span><br><span class="line">main&#123;</span><br><span class="line">java&#123;</span><br><span class="line">scrDir &apos;src/java&apos; // 设置main源集的java源文件的目录</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/Gradle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01.png" alt="enter description here" title="Gradle学习笔记4.png"></p><p><img src="/images/Gradle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01.png" alt="enter description here" title="Gradle学习笔记5.png"></p><h1 id="Android的Gradle"><a href="#Android的Gradle" class="headerlink" title="Android的Gradle"></a>Android的Gradle</h1><h2 id="各属性"><a href="#各属性" class="headerlink" title="各属性"></a>各属性</h2><p>compileSdkVersion//编译的androidSDK版本,可为int或String<br>BuildToosVersion//构建版本,23.0.1<br>defaultConfig//默认配置,配置生产模式,多渠道打包<br>buildTypes//配置源文件资源文件,混淆,文件目录</p><h3 id="defaultConfig配置"><a href="#defaultConfig配置" class="headerlink" title="defaultConfig配置"></a>defaultConfig配置</h3><p>applicationId//指定生成的报名,默认为null,会从manifest中读取<br>minSdkVersion//App支持的最低Android版本<br>targetSdkVersion//App是基于那个android版本开发的,默认为null,会从manifest读取<br>versionCode//App内部版本,给内部人员看的<br>versionName//与versionCode类似,但其是给用户看的外部版本<br>testApplicationId//测试App的包名,一般使用默认的,applicationId+’test’<br>testInstructionRunner//配置单元测试使用的Runner,默认为android.test.InstrumentationTestRunner<br>proguardFile//设置一个混淆文件<br>proguardFiles//设置多个混淆文件<br>signingConfig//配置签名信息<br>signingConfigs//配置多个签名信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">android&#123;</span><br><span class="line">compileSdkVersion 23</span><br><span class="line">buildToolsVersion &quot;23.0.1&quot;</span><br><span class="line"></span><br><span class="line">signingConfigs&#123;</span><br><span class="line">release&#123;//正式版</span><br><span class="line">storeFile file(&quot;myreleasekey.keystore&quot;)//设置签名文件</span><br><span class="line">storePassword &quot;password&quot;//签名的store密码</span><br><span class="line">keyAlias &quot;Alias&quot;//签名的Alias</span><br><span class="line">keyPassword &quot;password&quot;//签名的key密码</span><br><span class="line">&#125;</span><br><span class="line">debug&#123;//debug版</span><br><span class="line">....</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">defaultConfig&#123;</span><br><span class="line">applicationId &quot;cn.com.lewis_v.test&quot;</span><br><span class="line">minSdkVersion 14</span><br><span class="line">targetSdkVersion 23</span><br><span class="line">versionCode 1</span><br><span class="line">versionName &quot;1.0.1&quot;</span><br><span class="line">//signingConfig signingConfigs.debug//使用Debug签名</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">buildTypes&#123;</span><br><span class="line">release&#123;</span><br><span class="line">signingConfig signingConfigs.release//此处也能设置签名</span><br><span class="line">&#125;</span><br><span class="line">debug&#123;</span><br><span class="line">signingConfig.signingConfigs.debug</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="buildTypes配置"><a href="#buildTypes配置" class="headerlink" title="buildTypes配置"></a>buildTypes配置</h3><p>applicationIdSuffix//配置applicationId的后缀,相当于改包名了<br>debuggable//配置生成的apk是否可调试<br>jniDebuggable//配置生成的apk是否可进行jni调试<br>minifyEnabled//是否启用混淆<br>multiDexEnabled//是否启用分包,方法超过65535时需要拆分多个包<br>proguardFile//配置混淆文件<br>proguardFile//配置多个混淆文件<br>shrinkResources//是否自动清理未使用的资源,默认false<br>signingConfig//配置签名信息<br>testFunctionalTest//是否为功能测试<br>testHandleProfiling//是否启用分析功能<br>useJack//是否启用,新的编译器,这个编译器更快,但是目前还不成熟</p><p>可以看到buildTypes和defaultConfig有些属性重复了,但一般默认配置在前,然后在buildType中根据不同渠道去修改相关属性,未设置的就是用默认配置</p><h3 id="zipalign优化"><a href="#zipalign优化" class="headerlink" title="zipalign优化"></a>zipalign优化</h3><p>android提供的整理优化apk的工具,可提高运行效率,降低内存使用,使用方法很简单<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">android&#123;</span><br><span class="line">buildTypes&#123;</span><br><span class="line">release&#123;</span><br><span class="line">zipAlignEnabled true//启用zipAlign</span><br><span class="line">&#125;</span><br><span class="line">debug&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="使用共享库"><a href="#使用共享库" class="headerlink" title="使用共享库"></a>使用共享库</h1><p>如在6.0之后httpClient被删除了,要使用的话需要手动添加共享库,build.gradle中为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">android&#123;</span><br><span class="line">useLibrary(&apos;org.apache.http.legacy&apos;)</span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>manifest.xml,这里不写不会出错<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-library</span><br><span class="line">android:name=&quot;org.apache.http.legacy&quot;</span><br><span class="line">android:required=&quot;true&quot;</span><br></pre></td></tr></table></figure></p><h1 id="gradle中使用命令行"><a href="#gradle中使用命令行" class="headerlink" title="gradle中使用命令行"></a>gradle中使用命令行</h1><p>gradle提供了exec来执行shell命令,<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def stdout = new ByteArrayOutputStream()</span><br><span class="line">exec&#123;</span><br><span class="line">commandLine &apos;git&apos;,&apos;tag&apos;,&apos;--list&apos;</span><br><span class="line">standardOutput = stdout//获取命令执行的返回</span><br><span class="line">&#125;</span><br><span class="line">return stdout.toString()</span><br></pre></td></tr></table></figure></p><h1 id="动态设置Manifest"><a href="#动态设置Manifest" class="headerlink" title="动态设置Manifest"></a>动态设置Manifest</h1><p>可使用Gradle动态替换manifest中${}占位符<br>manifest.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta-data android:value=&quot;$&#123;TEST&#125;&quot; android:name=&quot;test&quot;/&gt;</span><br></pre></td></tr></table></figure></p><p>在gradle中使用manifestPlaceholders来替换<br>gradle<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">productFlavors&#123;</span><br><span class="line">google&#123;</span><br><span class="line">manifestPlaceholders.put(&quot;TEST&quot;,&quot;google&quot;)</span><br><span class="line">&#125;</span><br><span class="line">baidu&#123;</span><br><span class="line">manifestPlaceholders.put(&quot;TEST&quot;,&quot;baidu&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可使用遍历所有productFlavors来替换,这样可能没那么灵活,但是对于很多渠道且不通点可在productFlavors中获取的时候,使用会很方便<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">productFlavors.all&#123;</span><br><span class="line">google&#123;</span><br><span class="line">&#125;</span><br><span class="line">baidu&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">productFlavors.all&#123;flavor-&gt;</span><br><span class="line">manifestPlaceholders.put(&quot;TEST&quot;,name)//此处的那么是闭包名/任务名,也就是上面的google和baidu</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="BuildConfig"><a href="#BuildConfig" class="headerlink" title="BuildConfig"></a>BuildConfig</h1><p>BuildConfig中包含了基本版本信息,如版本号,渠道,是否为DEBUG模式,其不可修改,而且是自动生成的</p><p>如平常获取包名使用context.getPackageName(),这里面实现较为复杂,性能不高,而使用BuildConfig.APPLICATION_ID获取到的就很方便,且其为一个全局的静态变量,获取的性能高</p><p>而其中的BuildConfig.DEBUG,标记是否为DEBUG模式,是则为true,不是则为false</p><p>当然也可以在构建的时候向BuildConfig加入我们自定义的参数,格式为:<br>BuildConfigField ‘type’,’name’,’value’//依次为类型,参数名,参数值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">buildTypes&#123;</span><br><span class="line">release&#123;</span><br><span class="line">BuildConfigField &apos;String&apos;,&apos;HOST&apos;,&apos;&quot;http://www.baidu.com&quot;&apos;</span><br><span class="line">&#125;</span><br><span class="line">debug&#123;</span><br><span class="line">BuildConfigField &apos;String&apos;,&apos;HOST&apos;,&apos;&quot;http://www.google.com&quot;&apos;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样,在正式包下,BuildConfig.HOST的值为baidu的,测试包下为google,这里需要注意的是参数值为String的需要有双引号’”xxxx”‘,如果写成了’xxx’,会出错,原因是他在文件中会写成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static final String HOST = www.baidu.com;//这样会出错,因为后面的不会被识别为字符串</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static final String HOST = &quot;www.baidu.com&quot;;//这样才是正确的</span><br></pre></td></tr></table></figure><h1 id="自定义资源文件的内容"><a href="#自定义资源文件的内容" class="headerlink" title="自定义资源文件的内容"></a>自定义资源文件的内容</h1><p>一般使用的资源文件,如string.xml,color.xml等,都可以在gradle中动态修改,在buildTypes和productFlavors中都可以修改<br>使用resValue ‘type’,’name’,’value’//这里和BuildConfig类似,type为资源类型,如string,name是资源中的标识名字,value是要设置为什么值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">productFlavors&#123;</span><br><span class="line">google&#123;</span><br><span class="line">resValue &apos;string&apos;,&apos;app_name&apos;,&apos;google&apos;</span><br><span class="line">&#125;</span><br><span class="line">baidu&#123;</span><br><span class="line">resvalue &apos;string&apos;,&apos;app_name&apos;,&apos;baidu&apos;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述代码,可在不同渠道下,修改string.xml中的app_name的值</p><h1 id="JAVA编译选项"><a href="#JAVA编译选项" class="headerlink" title="JAVA编译选项"></a>JAVA编译选项</h1><p>为设置java编译的JDK版本,文件编码,在android{}中提供了compileOption来设置这些,其中只提供了三个属性encoding(编码格式),sourceCompatibility和targetCompatibility为JDK版本号<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">android&#123;</span><br><span class="line">compileOptions&#123;</span><br><span class="line">encoding = &apos;utf-8&apos;</span><br><span class="line">sourceCompatibility = JavaVersion.VERSION_1_8</span><br><span class="line">targetCompatibility = JavaVersion.VERSION_1_8</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="adb操作配置"><a href="#adb操作配置" class="headerlink" title="adb操作配置"></a>adb操作配置</h1><p>gradle中提供了对adb命令的配置,其中配置的属性为两个timeOutInMs(超时),installOptions(安装配置)<br>这个也是android{}中提供的adbOptions设置的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">android&#123;</span><br><span class="line">adbOptions&#123;</span><br><span class="line">timeOutInMs = 5*1000//5秒超时</span><br><span class="line">installOptions &apos;-r&apos;,&apos;-s&apos;//安装配置</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中timeOutInMs为adb命令反应超时,在指定时间内无反馈则视为超时,报错CommandRejectException<br>installOptions安装的命令配置,<br>-l:锁定该应用程序;<br>-r:强制安装;<br>-t:允许测试包;<br>-s:安装到SD卡上;<br>-d:允许降级安装;-<br>g:授予运行时权限;</p><h1 id="dex选项"><a href="#dex选项" class="headerlink" title="dex选项"></a>dex选项</h1><p>配置dex命令运行的选项<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">android&#123;</span><br><span class="line">javaMaxHeapSize &quot;2g&quot;//调用dx命令是,分配最大的堆内存,看电脑的配置</span><br><span class="line">incremental true//开启增量模式,默认为false</span><br><span class="line">jumboMode true//开启jumbo模式,用于突破65535方法数限制</span><br><span class="line">threadCount 2//运行dx命令时的线程数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="资源自动清理"><a href="#资源自动清理" class="headerlink" title="资源自动清理"></a>资源自动清理</h1><p>在工程中,会应用第三方资源或有自己的代码不使用的,所以在gradle中提供打包时不将无用资源打包的设置</p><h2 id="shrink"><a href="#shrink" class="headerlink" title="shrink"></a>shrink</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">android&#123;</span><br><span class="line">buildTypes&#123;</span><br><span class="line">release&#123;</span><br><span class="line">shrinkResources true//开启自动清理,默认为false</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开启很简单,但是其清理会清理未被引用的资源,但是有些使用反射的会识别不到,所以gradle提供了keep文件来设置不清理的文件,res/raw/keep.xml(不存在需要自己新建文件)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;resources xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">tools:keep=&quot;@layout/xxx*,@layout/xx&quot;</span><br><span class="line">tools:shrinkMode=&quot;safe&quot;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure></p><p>其中keep为不清理文件,支持*通配符,用逗号分隔文件<br>shrinkMode为清理模式,默认safe,一般用safe就好了</p><h2 id="resConfig"><a href="#resConfig" class="headerlink" title="resConfig"></a>resConfig</h2><p>resConfig可配置只需要什么资源<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">android&#123;</span><br><span class="line">defaultConfig&#123;</span><br><span class="line">resConfig &apos;zh&apos;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="修改发布的aar包"><a href="#修改发布的aar包" class="headerlink" title="修改发布的aar包"></a>修改发布的aar包</h1><p>修改发布的arr包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">android&#123;</span><br><span class="line">defaultPublishConfig &quot;dubug&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>发布多个arr包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">android&#123;</span><br><span class="line">publishNonDefault true//开启多个arr包</span><br><span class="line">&#125;</span><br><span class="line">dependencies&#123;</span><br><span class="line">flavo1Compile project(path:&apos;:lib1&apos;,configuration:&apos;flavor1Release&apos;)</span><br><span class="line">flavo2Compile project(path:&apos;:lib1&apos;,configuration:&apos;flavor2Release&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="Junit测试"><a href="#Junit测试" class="headerlink" title="Junit测试"></a>Junit测试</h1><p>这个好像也叫单元测试,针对纯java的测试<br>使用单元测试需要导入Junit依赖,不过一般工程都自动导入了.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    testImplementation &apos;junit:junit:4.12&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在java目录下有三个包,其中有一个为test的另两个为主程序和androidTest(这是android环境的测试)<br>test包下的就是单元测试方法的编辑<br>例如要测试一个自己的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class TestUtil &#123;</span><br><span class="line">    public String get()&#123;</span><br><span class="line">        return &quot;777&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在test中新建一个类用于单元测试MyTest.java,这个代码不会加入apk包中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import org.junit.Test;</span><br><span class="line">import static org.junit.Assert.*;</span><br><span class="line"></span><br><span class="line">public class MyTest &#123;</span><br><span class="line">    @Test</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        assertEquals(new TestUtil().get(),&quot;666&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中@Test为声名此方法为测试方法,声名后再单元测试的时候会调用此方法进行测试<br>还有assert系列方法,这里的assertEquals是判断两个参数是否相同,不同会有错误提示<br>在命令框使用 gradle test 进行单元测试,测试结果会在app/build/reports/tests/testDebugUnitTest/classes中已HTML的形式保存,这了一个测试类会生成一个HTML文件</p><h1 id="测试配置"><a href="#测试配置" class="headerlink" title="测试配置"></a>测试配置</h1><p>可配置测试结果数据的目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">android&#123;</span><br><span class="line">testOptions&#123;</span><br><span class="line">reportDir = &quot;$project.buildDir/app/report&quot;//$project.buildDir为工程更目录</span><br><span class="line">resultsDir = &quot;$project.buildDir/app/result&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="代码覆盖率"><a href="#代码覆盖率" class="headerlink" title="代码覆盖率"></a>代码覆盖率</h1><p>检测测试用例的覆盖率<br>需要在buildTypes中开启testCoverageEnabled,并导入jacoco<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">apply plugin: &apos;jacoco&apos;</span><br><span class="line">...</span><br><span class="line">android&#123;</span><br><span class="line">...</span><br><span class="line">buildTypes&#123;</span><br><span class="line">debug&#123;</span><br><span class="line">testCoverageEnabled true</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">jacoco&#123;</span><br><span class="line">    toolVersion = &quot;0.7.1.201405082137&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用命令进行测试 gradle createDebugCoverageReport<br>结果在app\build\reports\coverage\debug\index.html中</p><h1 id="Lint测试"><a href="#Lint测试" class="headerlink" title="Lint测试"></a>Lint测试</h1><p>检查哪些代码没被使用,哪些使用新API等,生成一个报告,告诉哪里需要优化.<br>在gradle中使用lintOptions进行配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">android&#123;</span><br><span class="line">lintOptions&#123;</span><br><span class="line">abortOnError true//发现错误是否退出构建</span><br><span class="line">absolutePaths false//错误的输出是否显示绝对路径,默认为相对路径</span><br><span class="line">check &apos;NewApi&apos;//设置需要检测哪些Lint检查,具体项目使用命令查看lint --list</span><br><span class="line">checkAllWarning true//是否检测所有警告的issue</span><br><span class="line">checkReleaseBuilds true//在release中是否检测致命错误,出现错误终止构建</span><br><span class="line">disable &apos;NewApi&apos;//关闭哪些issue检查</span><br><span class="line">enable &apos;NewApi&apos;//开启哪些检查</span><br><span class="line">explainIssues true//错误报告是否包含解释说明</span><br><span class="line">htmlOutput new File(&quot;xxx&quot;)//配置Html报告的输出路径</span><br><span class="line">htmlReport true//是否生成html报告</span><br><span class="line">ignoreWarnings false//是否忽略警告级别的检查</span><br><span class="line">lintConfig new File(&quot;xxx&quot;)//指定Lint的配置文件,一个Xml文件</span><br><span class="line">noLines true//错误信息中,是否不包含源代码中的行号</span><br><span class="line">quiet false//是否安静模式,安静模式不会显示分析进度</span><br><span class="line">severityOverrides//返回一个Map结果,内容为个issue的优先级</span><br><span class="line">showAll true//是否显示全部输出,不为true,较长的信息会被截断</span><br><span class="line">textOutput new File(&quot;xxx&quot;)//生成text报告的路径</span><br><span class="line">textReport false//是否生成text报告</span><br><span class="line">warningAsErrors false//所有警告是否当成错误处理</span><br><span class="line">xmlOutput new File(&quot;xxx&quot;)//xml报告输出路径</span><br><span class="line">xmlReport true//是否生成xml报告</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="本笔记是学习《Android-Gradle-权威指南》作的笔记，当中有些内容可能错误或描述不清晰的，敬请谅解"><a href="#本笔记是学习《Android-Gradle-权威指南》作的笔记，当中有些内容可能错误或描述不清晰的，敬请谅解" class="headerlink" title="本笔记是学习《Android Gradle 权威指南》作的笔记，当中有些内容可能错误或描述不清晰的，敬请谅解~~"></a>本笔记是学习《Android Gradle 权威指南》作的笔记，当中有些内容可能错误或描述不清晰的，敬请谅解~~</h3>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>自定义YCardLayout</title>
      <link href="/2018/04/18/%E8%87%AA%E5%AE%9A%E4%B9%89YCardLayout/"/>
      <url>/2018/04/18/%E8%87%AA%E5%AE%9A%E4%B9%89YCardLayout/</url>
      <content type="html"><![CDATA[<p>这是一个卡片式滑动的控件<br><a id="more"></a><br>屁话不多说，先上个效果图先<br><img src="/images/YCardLayout.gif" alt="效果图1" title="效果图1"></p><p>将此控件放到RecyclerView中，并自定义LayoutManager可以有这样的效果<br><img src="/images/YCardLayout2.gif" alt="效果图2" title="效果图2"></p><p>github：<a href="https://github.com/lewis-v/YCardLayout" target="_blank" rel="noopener">https://github.com/lewis-v/YCardLayout</a></p><h1 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h1><h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><p>Add it in your root build.gradle at the end of repositories:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">allprojects &#123;</span><br><span class="line">repositories &#123;</span><br><span class="line">...</span><br><span class="line">maven &#123; url &apos;https://jitpack.io&apos; &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Add the dependency<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">        compile &apos;com.github.lewis-v:YCardLayout:1.0.1&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="在布局中使用"><a href="#在布局中使用" class="headerlink" title="在布局中使用"></a>在布局中使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;com.lewis_v.ycardlayoutlib.YCardLayout</span><br><span class="line">      android:id=&quot;@+id/fl&quot;</span><br><span class="line">      android:layout_marginTop=&quot;20dp&quot;</span><br><span class="line">      app:layout_constraintLeft_toLeftOf=&quot;parent&quot;</span><br><span class="line">      app:layout_constraintRight_toRightOf=&quot;parent&quot;</span><br><span class="line">      android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">      android:layout_height=&quot;wrap_content&quot;&gt;</span><br><span class="line">      &lt;ImageView</span><br><span class="line">          android:id=&quot;@+id/img&quot;</span><br><span class="line">          android:layout_margin=&quot;5dp&quot;</span><br><span class="line">          android:src=&quot;@mipmap/ic_launcher&quot;</span><br><span class="line">          android:layout_width=&quot;200dp&quot;</span><br><span class="line">          android:layout_height=&quot;200dp&quot; /&gt;</span><br><span class="line">  &lt;/com.lewis_v.ycardlayoutlib.YCardLayout&gt;</span><br></pre></td></tr></table></figure><h2 id="代码中进行操作"><a href="#代码中进行操作" class="headerlink" title="代码中进行操作"></a>代码中进行操作</h2><p>控件中已有默认的配合参数,所以可以直接使用,不进行配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">yCardLayout = findViewById(R.id.fl);</span><br><span class="line">        //yCardLayout.setMaxWidth(yCardLayout.getWidth());//设置最大移动距离</span><br><span class="line">        //yCardLayout.setMoveRotation(45);//最大旋转角度</span><br><span class="line">        //yCardLayout.reset();//重置数据</span><br><span class="line"></span><br><span class="line">        img = findViewById(R.id.img);</span><br><span class="line">        img.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(View v) &#123;</span><br><span class="line">                yCardLayout.removeToLeft(null);</span><br><span class="line">                Toast.makeText(MainActivity.this,&quot;点击11&quot;,Toast.LENGTH_SHORT).show();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></p><h1 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h1><h2 id="自定义控件继承于Framelayout及初始化"><a href="#自定义控件继承于Framelayout及初始化" class="headerlink" title="自定义控件继承于Framelayout及初始化"></a>自定义控件继承于Framelayout及初始化</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class YCardLayout extends FrameLayout &#123;</span><br><span class="line">public void init(Context context)&#123;</span><br><span class="line">        setClickable(true);</span><br><span class="line">        setEnabled(true);</span><br><span class="line">        minLength = ViewConfiguration.get(context).getScaledTouchSlop();//获取设备最小滑动距离</span><br><span class="line">        post(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                maxWidth = getWidth();//默认移动最大距离为控件的宽度,这里的参数用于旋转角度的变化做参照</span><br><span class="line">                firstPoint = new Point((int) getX(),(int)getY());//获取初始位置</span><br><span class="line">                isInit = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现移动的动画-还用移动时的旋转"><a href="#实现移动的动画-还用移动时的旋转" class="headerlink" title="实现移动的动画,还用移动时的旋转"></a>实现移动的动画,还用移动时的旋转</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">   public boolean onTouchEvent(MotionEvent event) &#123;</span><br><span class="line">       if (!isRemove &amp;&amp; moveAble &amp;&amp; isInit &amp;&amp; !isRunAnim) &#123;</span><br><span class="line">           switch (event.getAction()) &#123;</span><br><span class="line">               case MotionEvent.ACTION_DOWN:</span><br><span class="line">                   //获取点击时的数据,并存起来</span><br><span class="line">                   cacheX = event.getRawX();</span><br><span class="line">                   cacheY = event.getRawY();</span><br><span class="line">                   downX = event.getRawX();</span><br><span class="line">                   downY = event.getRawY();</span><br><span class="line">                   if (firstPoint == null) &#123;//这个正常情况不会执行,在这里只是以防万一</span><br><span class="line">                       firstPoint = new Point((int) getX(), (int) getY());</span><br><span class="line">                   &#125;</span><br><span class="line">                   return true;</span><br><span class="line">               case MotionEvent.ACTION_MOVE:</span><br><span class="line">                   if ((Math.abs(downX-event.getRawX()) &gt; minLength || Math.abs(downY-event.getRawY()) &gt; minLength)) &#123;//只有大于最小滑动距离才算移动了</span><br><span class="line">                       float moveX = event.getRawX();</span><br><span class="line">                       float moveY = event.getRawY();</span><br><span class="line"></span><br><span class="line">                       if (moveY &gt; 0) &#123;</span><br><span class="line">                           setY(getY() + (moveY - cacheY));//移动Y轴</span><br><span class="line">                       &#125;</span><br><span class="line">                       if (moveX &gt; 0) &#123;</span><br><span class="line">                           setX(getX() + (moveX - cacheX));//移动X轴</span><br><span class="line">                           float moveLen = (moveX - downX) / maxWidth;</span><br><span class="line">                           int moveProgress = (int) ((moveLen) * 100);//移动的距离占整个控件的比例moveProgress%</span><br><span class="line">                           setRotation((moveLen) * 45f);//控制控件的旋转</span><br><span class="line">                           if (onYCardMoveListener != null) &#123;</span><br><span class="line">                               onYCardMoveListener.onMove(this, moveProgress);//触发移动的监听器</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                       cacheX = moveX;</span><br><span class="line">                       cacheY = moveY;</span><br><span class="line">                   &#125;</span><br><span class="line">                   return false;</span><br><span class="line">               case MotionEvent.ACTION_UP:</span><br><span class="line">                   if ((Math.abs(downX-event.getRawX()) &gt; minLength || Math.abs(downY-event.getRawY()) &gt; minLength)) &#123;//移动了才截获这个事件</span><br><span class="line">                       int moveEndProgress = (int) (((event.getRawX() - downX) / maxWidth) * 100);</span><br><span class="line">                       if (onYCardMoveListener != null) &#123;</span><br><span class="line">                           if (onYCardMoveListener.onMoveEnd(this, moveEndProgress)) &#123;//移动结束事件</span><br><span class="line">                               return true;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                       animToReBack(this, firstPoint);//复位</span><br><span class="line">                       return true;</span><br><span class="line">                   &#125;</span><br><span class="line">                   break;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return false;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="加入移动后的复位动画"><a href="#加入移动后的复位动画" class="headerlink" title="加入移动后的复位动画"></a>加入移动后的复位动画</h2><p>上面的代码调用了animToReBack(this, firstPoint);来进行复位<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 复位动画</span><br><span class="line">     * @param view</span><br><span class="line">     * @param point 复位的位置</span><br><span class="line">     */</span><br><span class="line">    public void animToReBack(View view,Point point)&#123;</span><br><span class="line">        AnimatorSet animatorSet = getAnimToMove(view,point,0,getAlpha());//获取动画</span><br><span class="line">        isRunAnim = true;//动画正在运行的标记</span><br><span class="line">        animatorSet.addListener(new Animator.AnimatorListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onAnimationStart(Animator animation) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onAnimationEnd(Animator animation) &#123;</span><br><span class="line">                isRunAnim = false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onAnimationCancel(Animator animation) &#123;</span><br><span class="line">                isRunAnim = false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onAnimationRepeat(Animator animation) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        animatorSet.start();//开始复位动画</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>控件里的所有动画都通过getAnimToMove来获取,getAnimToMove的代码为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * 移动动画</span><br><span class="line">    * @param view</span><br><span class="line">    * @param point</span><br><span class="line">    * @param rotation</span><br><span class="line">    */</span><br><span class="line">   public AnimatorSet getAnimToMove(View view, Point point, float rotation,float alpha)&#123;</span><br><span class="line">       ObjectAnimator objectAnimatorX = ObjectAnimator.ofFloat(view,&quot;translationX&quot;,point.x);</span><br><span class="line">       ObjectAnimator objectAnimatorY = ObjectAnimator.ofFloat(view,&quot;translationY&quot;,point.y);</span><br><span class="line">       ObjectAnimator objectAnimatorR = ObjectAnimator.ofFloat(view,&quot;rotation&quot;,rotation);</span><br><span class="line">       ObjectAnimator objectAnimatorA = ObjectAnimator.ofFloat(view,&quot;alpha&quot;,alpha);</span><br><span class="line">       AnimatorSet animatorSet = new AnimatorSet();</span><br><span class="line">       animatorSet.playTogether(objectAnimatorR,objectAnimatorX,objectAnimatorY,objectAnimatorA);</span><br><span class="line">       return animatorSet;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>到这里,控件就可以移动和复位了,到了删除动画的实现了</p><h2 id="删除动画"><a href="#删除动画" class="headerlink" title="删除动画"></a>删除动画</h2><p>删除动画有左边的右边删除,删除的移动轨迹,需要与滑动方向相关,这样看起来的效果才比较好<br>这里写了两个方法,供删除时调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     *  向左移除控件</span><br><span class="line">     * @param removeAnimListener</span><br><span class="line">     */</span><br><span class="line">    public void removeToLeft(RemoveAnimListener removeAnimListener)&#123;</span><br><span class="line">        remove(true,removeAnimListener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 向右移除控件</span><br><span class="line">     * @param removeAnimListener</span><br><span class="line">     */</span><br><span class="line">    public void removeToRight(RemoveAnimListener removeAnimListener)&#123;</span><br><span class="line">        remove(false,removeAnimListener);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>其中remove方法实现为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 移除控件并notify</span><br><span class="line">     * @param isLeft 是否是向左</span><br><span class="line">     * @param removeAnimListener</span><br><span class="line">     */</span><br><span class="line">    public void remove(boolean isLeft, final RemoveAnimListener removeAnimListener)&#123;</span><br><span class="line">        isRemove = true;</span><br><span class="line">        final Point point = calculateEndPoint(this,this.firstPoint,isLeft);//计算终点坐标</span><br><span class="line">        AnimatorSet animatorSet = getReMoveAnim(this,point,getRemoveRotation(this,this.firstPoint,isLeft));//获取移除动画</span><br><span class="line">        animatorSet.addListener(new Animator.AnimatorListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onAnimationStart(Animator animation) &#123;</span><br><span class="line">                if (removeAnimListener != null)&#123;</span><br><span class="line">                    removeAnimListener.OnAnimStart(YCardLayout.this);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onAnimationEnd(Animator animation) &#123;</span><br><span class="line">                if (removeAnimListener != null)&#123;</span><br><span class="line">                    removeAnimListener.OnAnimEnd(YCardLayout.this);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onAnimationCancel(Animator animation) &#123;</span><br><span class="line">                Log.e(&quot;cancel&quot;,&quot;&quot;);</span><br><span class="line">                reset();</span><br><span class="line">                if (removeAnimListener != null)&#123;</span><br><span class="line">                    removeAnimListener.OnAnimCancel(YCardLayout.this);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onAnimationRepeat(Animator animation) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        animatorSet.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>在动画开始/结束/取消懂提供了回调,当然不需要时传入null就行了<br>其中调用计算终点坐标的方法,这个不好解释,看看计算过程,详细的就不说了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * 计算移除动画终点</span><br><span class="line">    * @param view</span><br><span class="line">    * @param point</span><br><span class="line">    * @param isLeft</span><br><span class="line">    * @return</span><br><span class="line">    */</span><br><span class="line">   public Point calculateEndPoint(View view, Point point, boolean isLeft)&#123;</span><br><span class="line">       Point endPoint = new Point();</span><br><span class="line">       if (isLeft) &#123;</span><br><span class="line">           endPoint.x = point.x - (int) (view.getWidth() * 1.5);</span><br><span class="line">       &#125;else &#123;</span><br><span class="line">           endPoint.x = point.x + (int) (view.getWidth() * 1.5);</span><br><span class="line">       &#125;</span><br><span class="line">        if (Math.abs(view.getX() - point.x) &lt; minLength &amp;&amp;Math.abs (view.getY()-point.y) &lt; minLength)&#123;//还在原来位置</span><br><span class="line">           endPoint.y = point.y + (int)(view.getHeight()*1.5);</span><br><span class="line">       &#125;else &#123;</span><br><span class="line">           int endY = getEndY(view,point);</span><br><span class="line">           if (isLeft) &#123;</span><br><span class="line">               endPoint.y = (int) view.getY() - endY;</span><br><span class="line">           &#125;else &#123;</span><br><span class="line">               endPoint.y = (int)view.getY() + endY;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return endPoint;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * 获取终点Y轴与初始位置Y轴的距离</span><br><span class="line">    * @param view</span><br><span class="line">    * @param point</span><br><span class="line">    * @return</span><br><span class="line">    */</span><br><span class="line">   public int getEndY(View view,Point point)&#123;</span><br><span class="line">       return (int) ((point.y-view.getY())/(point.x-view.getX())*1.5*view.getWidth());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>而移除的动画,内部其实也是调用了getAnimToMove(),只是传入的旋转度为当前的旋转度,且透明度变化结束为0</p><p>到这里控件已经可以有移除动画了,但是会发现控件内的子控件的点击事件没有了,所以这里需要解决点击事件的冲突</p><h2 id="解决点击事件冲突"><a href="#解决点击事件冲突" class="headerlink" title="解决点击事件冲突"></a>解决点击事件冲突</h2><p>需要在onInterceptTouchEvent中,对事件进行分发处理,在down和up不截获,在move中选择性截获<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">   public boolean onInterceptTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">       boolean intercepted = super.onInterceptTouchEvent(ev);</span><br><span class="line">       if (!isInit || isRunAnim)&#123;</span><br><span class="line">           return false;</span><br><span class="line">       &#125;</span><br><span class="line">       switch (ev.getAction())&#123;</span><br><span class="line">           case MotionEvent.ACTION_DOWN:</span><br><span class="line">               downX = ev.getRawX();</span><br><span class="line">               downY = ev.getRawY();</span><br><span class="line">               cacheX = ev.getRawX();</span><br><span class="line">               cacheY = ev.getRawY();</span><br><span class="line">               if (firstPoint == null)&#123;</span><br><span class="line">                   firstPoint = new Point((int) getX(),(int) getY());</span><br><span class="line">               &#125;</span><br><span class="line">               intercepted = false;</span><br><span class="line">               break;</span><br><span class="line">           case MotionEvent.ACTION_MOVE:</span><br><span class="line">               if ((Math.abs(downX-ev.getRawX()) &gt; minLength || Math.abs(downY-ev.getRawY()) &gt; minLength) &amp;&amp; !isRemove &amp;&amp; moveAble)&#123;</span><br><span class="line">                   intercepted = true;</span><br><span class="line">               &#125;else &#123;</span><br><span class="line">                   intercepted = false;</span><br><span class="line">               &#125;</span><br><span class="line">               break;</span><br><span class="line">           case MotionEvent.ACTION_UP:</span><br><span class="line">               intercepted = false;</span><br><span class="line">               break;</span><br><span class="line">       &#125;</span><br><span class="line">       return intercepted;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>到这里YCardLayout就基本结束了,接下来就是与RecyclerView的结合了,结合之前要加个重置方法,用于重置控件数据,因为RecyclerView有复用的功能,不重置会被其他本控件影响<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * 重置数据</span><br><span class="line">    */</span><br><span class="line">   public void reset()&#123;</span><br><span class="line">       if (firstPoint != null) &#123;</span><br><span class="line">           setX(firstPoint.x);</span><br><span class="line">           setY(firstPoint.y);</span><br><span class="line">       &#125;</span><br><span class="line">       isRemove = false;</span><br><span class="line">       moveAble = true;</span><br><span class="line">       setRotation(0);</span><br><span class="line">       setAlpha(1);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><h1 id="结合RecyclerView"><a href="#结合RecyclerView" class="headerlink" title="结合RecyclerView"></a>结合RecyclerView</h1><h2 id="自定义LayoutManager"><a href="#自定义LayoutManager" class="headerlink" title="自定义LayoutManager"></a>自定义LayoutManager</h2><p>当然这里的Manager只是做示范作用,实际中可能会出现问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">public class YCardLayoutManager extends RecyclerView.LayoutManager &#123;</span><br><span class="line">    public static final String TAG = &quot;YCardLayoutManager&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public RecyclerView.LayoutParams generateDefaultLayoutParams() &#123;</span><br><span class="line">        return new RecyclerView.LayoutParams(RecyclerView.LayoutParams.WRAP_CONTENT,</span><br><span class="line">                RecyclerView.LayoutParams.WRAP_CONTENT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) &#123;</span><br><span class="line">        if (getItemCount() == 0) &#123;//没有Item，界面空着吧</span><br><span class="line">            detachAndScrapAttachedViews(recycler);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (getChildCount() == 0 &amp;&amp; state.isPreLayout()) &#123;//state.isPreLayout()是支持动画的</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        detachAndScrapAttachedViews(recycler);</span><br><span class="line">        setChildren(recycler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setChildren(RecyclerView.Recycler recycler)&#123;</span><br><span class="line">        for (int i = getItemCount()-1; i &gt;= 0; i--) &#123;</span><br><span class="line">            View view = recycler.getViewForPosition(i);</span><br><span class="line">            addView(view);</span><br><span class="line">            measureChildWithMargins(view,0,0);</span><br><span class="line">            calculateItemDecorationsForChild(view,new Rect());</span><br><span class="line">            int width = getDecoratedMeasurementHorizontal(view);</span><br><span class="line">            int height = getDecoratedMeasurementVertical(view);</span><br><span class="line">            layoutDecoratedWithMargins(view,0,0,width,height);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取某个childView在水平方向所占的空间</span><br><span class="line">     *</span><br><span class="line">     * @param view</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public int getDecoratedMeasurementHorizontal(View view) &#123;</span><br><span class="line">        final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams)</span><br><span class="line">                view.getLayoutParams();</span><br><span class="line">        return getPaddingRight()+getPaddingLeft()+getDecoratedMeasuredWidth(view) + params.leftMargin</span><br><span class="line">                + params.rightMargin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取某个childView在竖直方向所占的空间</span><br><span class="line">     *</span><br><span class="line">     * @param view</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public int getDecoratedMeasurementVertical(View view) &#123;</span><br><span class="line">        final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams)</span><br><span class="line">                view.getLayoutParams();</span><br><span class="line">        return getPaddingTop()+getPaddingBottom()+getDecoratedMeasuredHeight(view) + params.topMargin</span><br><span class="line">                + params.bottomMargin;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后在RecyclerView中使用YCardLayoutManager加上YCardLayout就能有最开始第二个动图那样的效果,但这里主要是自定义YCardLayout,在与RecyclerView使用的时候还需要对YCardLayoutManager进行相应的修改.目前使用时,在添加数据时需要使用notifyDataSetChanged()来进行刷新,删除时需要使用notifyItemRemoved(position)和notifyDataSetChanged()一起刷新,不然可能出现问题.</p><h1 id="The-End"><a href="#The-End" class="headerlink" title="The End"></a>The End</h1><p>在自定义这个控件中,主要是解决了点击事件的冲突,移除动画的终点计算,还有其他的冲突问题,这里的与RecyclerView的结合使用,其中使用的LayoutManager还有一些问题,将在完善后再加入到GitHub中.最后推荐本书《Android开发艺术探索》,这书还是挺不错的,这里解决点击事件冲突的也是在此书中看来的…</p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>滚动广告栏,自动滚动ViewPager--FlowView</title>
      <link href="/2018/04/18/%E6%BB%9A%E5%8A%A8%E5%B9%BF%E5%91%8A%E6%A0%8F-%E8%87%AA%E5%8A%A8%E6%BB%9A%E5%8A%A8ViewPager-FlowView/"/>
      <url>/2018/04/18/%E6%BB%9A%E5%8A%A8%E5%B9%BF%E5%91%8A%E6%A0%8F-%E8%87%AA%E5%8A%A8%E6%BB%9A%E5%8A%A8ViewPager-FlowView/</url>
      <content type="html"><![CDATA[<p>  好久都没时间写博客了,我都忘了博客是什么样的了,这次刚好找了点时间回来写写,刚好把最近做的东西来分享给有需要的人~这次带来的时自动滚动的ViewPager,并且将封装了小圆点功能</p><a id="more"></a><h1 id="FlowView"><a href="#FlowView" class="headerlink" title="FlowView"></a>FlowView</h1><p>轮播ViewPager<br>此控件对ViewPager循环轮播的实现进行封装,适用于一种View轮播及多种不同的View一起轮播,功能可能还有不完善的地方,后期会逐步完善</p><h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">repositories &#123;</span><br><span class="line">maven &#123; url &apos;https://jitpack.io&apos; &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> dependencies &#123;</span><br><span class="line">compile &apos;com.github.lewis-v:FlowView:1.0.3&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="YWFlowViewPager-循环滚动控件"><a href="#YWFlowViewPager-循环滚动控件" class="headerlink" title="YWFlowViewPager 循环滚动控件"></a>YWFlowViewPager 循环滚动控件</h1><h2 id="布局添加"><a href="#布局添加" class="headerlink" title="布局添加"></a>布局添加</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;com.lewis_v.widget.viewflow.YWFlowViewPager</span><br><span class="line">       android:id=&quot;@+id/viewpager&quot;</span><br><span class="line">       android:layout_width=&quot;match_parent&quot;</span><br><span class="line">       android:layout_height=&quot;200dp&quot;/&gt;</span><br></pre></td></tr></table></figure><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">flowview.setFlowView(imageViews);//添加显示的控件列表</span><br><span class="line">flowview.setFlowTime(3000);//设置轮播间隔ms,默认为5秒</span><br><span class="line">flowview.start(true);//开始轮播</span><br><span class="line">//设置对每页的点击事件</span><br><span class="line">flowview.setOnPageClickListener(new YWFlowViewPager.OnPageClickListener() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onPageClick(View view, int position) &#123;</span><br><span class="line">        Log.i(TAG, String.valueOf(position));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>#YWFlowView 对循环滚动控件进一步封装,添加了滚动的小圆点</p><h2 id="布局添加-1"><a href="#布局添加-1" class="headerlink" title="布局添加"></a>布局添加</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;com.lewis_v.widget.viewflow.YWFlowView</span><br><span class="line">      android:id=&quot;@+id/viewpager&quot;</span><br><span class="line">      android:layout_width=&quot;match_parent&quot;</span><br><span class="line">      android:layout_height=&quot;200dp&quot;/&gt;</span><br></pre></td></tr></table></figure><h2 id="初始化-与YWVFlowViewPager一样"><a href="#初始化-与YWVFlowViewPager一样" class="headerlink" title="初始化(与YWVFlowViewPager一样)"></a>初始化(与YWVFlowViewPager一样)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">viewpager.addFlowView(imageView).addFlowView(imageView1)//添加显示View,也可使用setFlowViewList()设置View列表</span><br><span class="line">               .setPointGravity(Gravity.RIGHT)//小圆点的位置</span><br><span class="line">.setPointLayoutBackground(R.color.blue)//设置圆点布局的背景颜色</span><br><span class="line">.setPointLayoutHeight(400)//设置圆点布局的背景高度</span><br><span class="line">.setPointSize(20,20)//设置圆点大小,宽与高</span><br><span class="line">.setPointMargins(20)//设置圆点间隔</span><br><span class="line">//以上的设置都有相应的默认设置,一般不需要在进行配置</span><br><span class="line">.start(this,true);//开始滚动,this为context的引用,true为是否滚动</span><br></pre></td></tr></table></figure><h2 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h2><p> 在生命周期内调用对应方法,用于暂停与恢复轮播<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  public void onResume() &#123;</span><br><span class="line">      super.onResume();</span><br><span class="line">      viewpager.resume();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void onPause() &#123;</span><br><span class="line">      super.onPause();</span><br><span class="line">      viewpager.pause();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h2 id="来个动图明白点"><a href="#来个动图明白点" class="headerlink" title="来个动图明白点"></a>来个动图明白点</h2><p><img src="/images/YViewPager.gif" alt="效果图"><br>附上:github : <a href="https://github.com/lewis-v/FlowView" target="_blank" rel="noopener">https://github.com/lewis-v/FlowView</a></p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>木有结尾</p><h2 id="若有问题请向作者反馈-605788229-qq-com"><a href="#若有问题请向作者反馈-605788229-qq-com" class="headerlink" title="若有问题请向作者反馈:(605788229@qq.com)"></a>若有问题请向作者反馈:(<a href="mailto:605788229@qq.com" target="_blank" rel="noopener">605788229@qq.com</a>)</h2>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>EventBus事件总线的实现</title>
      <link href="/2018/04/18/EventBus%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
      <url>/2018/04/18/EventBus%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<p>Y事件总线:基于java的Observe和Observable实现的事件总线<br>github地址:<a href="https://github.com/lewis-v/YEventBus" target="_blank" rel="noopener">https://github.com/lewis-v/YEventBus</a><br><a id="more"></a></p><h1 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h1><h2 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h2><p>Add it in your root build.gradle at the end of repositories:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">repositories &#123;</span><br><span class="line">...</span><br><span class="line">maven &#123; url &apos;https://jitpack.io&apos; &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> Add the dependency<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">        compile &apos;com.github.lewis-v:YEventBus:1.0.0&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="使用方式-1"><a href="#使用方式-1" class="headerlink" title="使用方式"></a>使用方式</h2><p>定义事件类TestEvent2继承于IEvent,并注册事件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">YEventBus.getInstance().subscriber(TestEvent2.class, new YObserver&lt;TestEvent2&gt;() &#123;//订阅事件,处理的所在的线程与分发的线程一致</span><br><span class="line">            @Override</span><br><span class="line">            public void onSuccess(TestEvent2 event) &#123;</span><br><span class="line">                Log.i(TAG,event.toString());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onFail(Exception e) &#123;</span><br><span class="line">                Log.e(TAG,e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">YEventBus.getInstance().subscriber(TestEvent.class, new YMainThreadObserver&lt;TestEvent&gt;() &#123;//订阅事件,会在主线程中处理</span><br><span class="line">            @Override</span><br><span class="line">            public void onSuccess(TestEvent event) &#123;</span><br><span class="line">                Log.i(TAG,event.toString());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onFail(Exception e) &#123;</span><br><span class="line">                Log.e(TAG,e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></p><p>发布事件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">YEventBus.getInstance().postMainEvent(TestEvent.class,new TestEvent(TAG));//发布在主线程分发的事件</span><br><span class="line"></span><br><span class="line">YEventBus.getInstance().postEvent(TestEvent.class,new TestEvent(TAG));//发布在子线程分发的事件</span><br></pre></td></tr></table></figure></p><p>取消订阅<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">YEventBus.getInstance().unSubscriber(TestEvent.class,observer);//取消某事件下的某个订阅者的订阅</span><br><span class="line">YEventBus.getInstance().unSubscriberEvent(TestEvent.class);//取消TestEvent整个系列事件的订阅</span><br><span class="line">YEventBus.getInstance().unSubscriberAll();//取消所有事件的订阅</span><br></pre></td></tr></table></figure></p><h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><h2 id="Observable与Observer"><a href="#Observable与Observer" class="headerlink" title="Observable与Observer"></a>Observable与Observer</h2><p>首先是使用java的Observable,在发布事件时需要先setChanged()在进行发布,否者是发布不了的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class YObservable extends Observable &#123;</span><br><span class="line"></span><br><span class="line">    public &lt;T extends IEvent&gt; void postEvent(T data)&#123;</span><br><span class="line">        setChanged();</span><br><span class="line">        notifyObservers(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后是java的Observer,这里实现了OnGetEvent接口,主要是要在本来的Observer接口上加上成功与失败的调用方法,其中Observer接口需要实现updata方法,此方法是在事件分发时调用的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface OnGetEvent&lt;E extends IEvent&gt; extends Observer&#123;</span><br><span class="line">    void onSuccess(E event);</span><br><span class="line">    void onFail(Exception e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>YObserver控制了事件的实际处理及异常的获取<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public abstract class YObserver&lt;E extends IEvent&gt; implements OnGetEvent&lt;E&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void update(Observable o, Object arg) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            onSuccess((E) arg);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            onFail(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里除了提供YObserver,还提供了YMainThreadObserver,此Observer的事件处理会在主线程中进行,添加此类的意义是,可以再发布时指定在主线程,也可以在订阅的时候指定在主线程,当然在订阅的时候指定的优先级比发布的时候指定优先级高.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public abstract class YMainThreadObserver&lt;E extends IEvent&gt; implements OnGetEvent&lt;E&gt;&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void update(final Observable o, final Object arg) &#123;</span><br><span class="line">        ThreadSchedule.getMainHandle().post(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    onSuccess((E) arg);</span><br><span class="line">                &#125;catch (Exception e)&#123;</span><br><span class="line">                    onFail(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Observable管理类"><a href="#Observable管理类" class="headerlink" title="Observable管理类"></a>Observable管理类</h2><p>YObservableManager用于管理Observable,内部定义了ConcurrentHashMap来存储Observable,其键值为对应事件的Class,在订阅和取消订阅会对map进行插入或遍历<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">public class YObservableManager &#123;</span><br><span class="line">    private ConcurrentHashMap&lt;Class,YObservable&gt; mObservableMap;</span><br><span class="line">    private IEventHandle handle;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public YObservableManager() &#123;</span><br><span class="line">        mObservableMap = new ConcurrentHashMap&lt;&gt;();</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public YObservableManager(ConcurrentHashMap&lt;Class, YObservable&gt; mObservableMap) &#123;</span><br><span class="line">        this.mObservableMap = mObservableMap;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void init()&#123;</span><br><span class="line">        handle = new YEventHandle();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 设置自定义的事件分发处理</span><br><span class="line">     * @param handle</span><br><span class="line">     */</span><br><span class="line">    public void setHandle(IEventHandle handle) &#123;</span><br><span class="line">        this.handle = handle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 发布消息</span><br><span class="line">     * @param event</span><br><span class="line">     * @param &lt;T&gt;</span><br><span class="line">     */</span><br><span class="line">    public &lt;T extends IEvent&gt; void postEvent(Class&lt;T&gt; event,T data)&#123;</span><br><span class="line">        YObservable observables = mObservableMap.get(event);</span><br><span class="line">        if (handle == null)&#123;</span><br><span class="line">            init();</span><br><span class="line">        &#125;</span><br><span class="line">        handle.postEvent(observables,data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 发布主线程消息</span><br><span class="line">     * @param event</span><br><span class="line">     * @param &lt;T&gt;</span><br><span class="line">     */</span><br><span class="line">    public &lt;T extends IEvent&gt; void postMainEvent(Class&lt;T&gt; event,T data)&#123;</span><br><span class="line">        YObservable observables = mObservableMap.get(event);</span><br><span class="line">        if (handle == null)&#123;</span><br><span class="line">            init();</span><br><span class="line">        &#125;</span><br><span class="line">        handle.postMainEvent(observables,data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 订阅事件</span><br><span class="line">     * @param event</span><br><span class="line">     * @param observer</span><br><span class="line">     * @param &lt;T&gt;</span><br><span class="line">     */</span><br><span class="line">    public &lt;T extends IEvent&gt; void subscriber(Class&lt;T&gt; event,OnGetEvent&lt;T&gt; observer)&#123;</span><br><span class="line">        if (mObservableMap.containsKey(event))&#123;</span><br><span class="line">            mObservableMap.get(event).addObserver(observer);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            YObservable observable = new YObservable();</span><br><span class="line">            observable.addObserver(observer);</span><br><span class="line">            mObservableMap.put(event, observable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 解除订阅</span><br><span class="line">     * @param event</span><br><span class="line">     * @param observer</span><br><span class="line">     * @param &lt;T&gt;</span><br><span class="line">     */</span><br><span class="line">    public &lt;T extends IEvent&gt; void unSubscriber(Class&lt;T&gt; event,YObserver&lt;T&gt; observer)&#123;</span><br><span class="line">        if (mObservableMap.containsKey(event))&#123;</span><br><span class="line">            mObservableMap.get(event).deleteObserver(observer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 解除一个事件系列的订阅</span><br><span class="line">     * @param event</span><br><span class="line">     */</span><br><span class="line">    public void unSubscriberEvent(Class&lt;? extends IEvent&gt; event)&#123;</span><br><span class="line">        if (mObservableMap.containsKey(event)) &#123;</span><br><span class="line">            mObservableMap.get(event).deleteObservers();</span><br><span class="line">            mObservableMap.remove(event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 解除所有事件订阅</span><br><span class="line">     */</span><br><span class="line">    public void unSubscriberAll()&#123;</span><br><span class="line">        for (Map.Entry&lt;Class,YObservable&gt; entry : mObservableMap.entrySet())&#123;</span><br><span class="line">            YObservable value = entry.getValue();</span><br><span class="line">            if (value != null)&#123;</span><br><span class="line">                value.deleteObservers();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mObservableMap.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 释放资源</span><br><span class="line">     */</span><br><span class="line">    public void destroy()&#123;</span><br><span class="line">        handle.destroy();</span><br><span class="line">        handle = null;</span><br><span class="line">        unSubscriberAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="事件的发布"><a href="#事件的发布" class="headerlink" title="事件的发布"></a>事件的发布</h2><p>上述代码中,在发布消息的时候会调用IEventHandle的postEvent,其实际的实现为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">public class YEventHandle implements IEventHandle&#123;</span><br><span class="line">    private ExecutorService executorServiceHandle;//处理线程池</span><br><span class="line"></span><br><span class="line">    public YEventHandle() &#123;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line">    private void init()&#123;</span><br><span class="line">        executorServiceHandle = Executors.newFixedThreadPool(2*Runtime.getRuntime().availableProcessors());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 发布消息</span><br><span class="line">     * @param observable</span><br><span class="line">     * @param data</span><br><span class="line">     * @param &lt;T&gt;</span><br><span class="line">     * @throws InterruptedException</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public &lt;T extends IEvent&gt; void postEvent(YObservable observable, T data) &#123;</span><br><span class="line">        handle(observable,data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 发布主线程处理消息</span><br><span class="line">     * @param observable</span><br><span class="line">     * @param data</span><br><span class="line">     * @param &lt;T&gt;</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public &lt;T extends IEvent&gt; void postMainEvent(YObservable observable, T data) &#123;</span><br><span class="line">        handleInMain(observable,data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 处理</span><br><span class="line">     * @param observable</span><br><span class="line">     * @param data</span><br><span class="line">     * @param &lt;T&gt;</span><br><span class="line">     */</span><br><span class="line">    private &lt;T extends IEvent&gt;  void handle(final YObservable observable, final T data)&#123;</span><br><span class="line">        executorServiceHandle.execute(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                if (observable != null) &#123;</span><br><span class="line">                    observable.postEvent(data);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 在主线程处理</span><br><span class="line">     * @param observable</span><br><span class="line">     * @param data</span><br><span class="line">     * @param &lt;T&gt;</span><br><span class="line">     */</span><br><span class="line">    private &lt;T extends IEvent&gt;  void handleInMain(final YObservable observable, final T data)&#123;</span><br><span class="line">        executorServiceHandle.execute(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                if (observable != null) &#123;</span><br><span class="line">                    ThreadSchedule.getMainHandle().post(new Runnable() &#123;</span><br><span class="line">                        @Override</span><br><span class="line">                        public void run() &#123;</span><br><span class="line">                            observable.postEvent(data);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 释放资源</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void destroy() &#123;</span><br><span class="line">        executorServiceHandle.shutdownNow();</span><br><span class="line">        executorServiceHandle = null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>事件的分发处理,会在一个线程池里进行,线程池的大小为Cpu核心数的2倍,当事件过多时会在线程池的队列中等待,需要注意的是对事件的处理尽量不要做太耗时的任务,不然把线程池中的所有线程都阻塞了会导致整个事件总线阻塞,后面的时间将无法继续发布.</p><h2 id="小结结"><a href="#小结结" class="headerlink" title="小结结"></a>小结结</h2><p>Y事件总线的实现只要是使用了java的Observable和Observer,其内部也是使用一个Vector类保存Observer,在发布的时候,遍历这里列表进行发布,这也是设计模式中的观察与被观察者的模式.</p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Hello~</title>
      <link href="/2018/04/14/Hello/"/>
      <url>/2018/04/14/Hello/</url>
      <content type="html"><![CDATA[<pre><code>欢迎来到,Lewis_v 的博客,在这里你可以了解到我对编程的理解及我对编程的学习路程~~</code></pre>]]></content>
      
      
    </entry>
    
  
  
    
    <entry>
      <title></title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      <content type="html"><![CDATA[<p>title: tags</p><h2 id="date-2018-04-15-07-38-47"><a href="#date-2018-04-15-07-38-47" class="headerlink" title="date: 2018-04-15 07:38:47"></a>date: 2018-04-15 07:38:47</h2>]]></content>
    </entry>
    
    <entry>
      <title></title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      <content type="html"><![CDATA[<p>title: categories</p><h2 id="date-2018-04-15-07-38-38"><a href="#date-2018-04-15-07-38-38" class="headerlink" title="date: 2018-04-15 07:38:38"></a>date: 2018-04-15 07:38:38</h2>]]></content>
    </entry>
    
    <entry>
      <title></title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      <content type="html"><![CDATA[<h1 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h1><pre><code>刘一为,90后程序员,17年入行Android开发。热爱编程、热爱代码设计。</code></pre><p><img src="/images/%E6%8A%80%E8%83%BD%E7%86%9F%E7%BB%83%E5%BA%A6.png" alt="技能熟练度" title="技能熟练度"></p><h2 id="个人作品"><a href="#个人作品" class="headerlink" title="个人作品"></a>个人作品</h2><h2 id="公总号"><a href="#公总号" class="headerlink" title="公总号"></a>公总号</h2><p><img src="/images/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7_%E4%BA%8C%E7%BB%B4%E7%A0%81_small.jpg" alt="Y代码" title="Y代码"></p><h2 id="与我联系"><a href="#与我联系" class="headerlink" title="与我联系"></a>与我联系</h2><p> QQ/微信:605788229<br> Email:<a href="mailto:605788229@qq.com" target="_blank" rel="noopener">605788229@qq.com</a></p>]]></content>
    </entry>
    
  
</search>
